<div class-rtable
  class-rtable-virtual="~/paginate === 'virtual'"
  class-rtable-auto="~/paginate === 'auto'"
  class-rtable-fixed="~/fixed"
  class-rtable-border="~/border"
  class-rtable-fixed-header="~/fixedHeader"
  class-rtable-scrolled-down="!~(~/scroll || '').indexOf('top')"
  class-rtable-scrolled-up="!~(~/scroll || '').indexOf('bottom')"
  class-rtable-with-select="~/allowSelect"
  class-rtable-valign-top="~/valign === 'top'"
  class-rtable-valign-center="~/valign === 'center'"
  class-rtable-valign-bottom="~/valign === 'bottom'"
  class-rtable-nowrap="~/noWrap"
  class-rtable-wrap="!~/noWrap"
  {{yield extra-attributes}}
>
  {{#if (!~/noHeader || meta.top) && ~/fixedHeader}}<div as-grid="{ offset: ~/scrollOffset }" class-rtable-header-fixed>
    {{#if meta.top}}<div class-rtable-header-extra {{#if ~/noWrap}}style-width="{{~/tableWidth}}px"{{/if}} class-rtable-noheader="~/noHeader" {{#if meta.topAttrs}}{{yield meta.topAttrs}}{{/if}}>{{yield meta.top with selections.length as selectedCount, rows.length as rowCount, @this as table, selected as selected, selections as selections}}</div>{{/if}}
    {{#unless ~/noHeader}}<div class-rtable-header-wrapper class-row-wrap {{#if ~/noWrap}}as-scrollother=`.rtable-top`{{/if}}>{{>grid-head}}</div>{{/unless}}
  </div>{{/if}}
  <div class-rtable-top {{#if ~/paginate === 'virtual'}}on-scroll="scroll" as-sized="{ offsetHeight: '~/tableHeight', diffWidth: '~/scrollOffset' }"{{/if}} {{#if (!~/noHeader && ~/fixedHeader) || ~/meta.bottom}}as-scrolled=`~/scroll`{{/if}} {{#if ~/fixedHeader && ~/noWrap}}as-scrollother=`.rtable-header-wrapper`{{/if}}>
    {{#if !~/fixedHeader && meta.top}}<div class-rtable-header-extra {{#if ~/noWrap}}style-width="{{~/tableWidth}}px"{{/if}} class-rtable-noheader="~/noHeader" {{#if meta.topAttrs}}{{yield meta.topAttrs}}{{/if}}>{{yield meta.top with selections.length as selectedCount, rows.length as rowCount, @this as table, selected as selected, selections as selections}}</div>{{/if}}
    <div as-grid="{ size: '~/tableWidth', value: '~/gridValue', name: '~/gridName', max: '~/gridMax' }" {{#if ~/paginate === 'virtual'}}style-margin-top="{{~/virtual.above}}px" style-margin-bottom="{{~/virtual.below}}px"{{/if}}>
      {{#if !~/noHeader && !~/fixedHeader}}
        <div class-rtable-header-wrapper class-row-wrap>{{>grid-head}}</div>
      {{/if}}
      {{#if ~/shuffle}}
        {{#each ~/visibleRows, ~/items as source, true as shuffle}}
          {{>grid-row}}
        {{/each}}
      {{else}}
        {{#each ~/visibleRows}}
          {{>grid-row}}
        {{/each}}
      {{/if}}
      {{#if !~/rows.length}}<div class-rtable-row class-row class-t1>{{yield empty with ~/empty as message}}</div>{{/if}}
    </div>
  </div>
  {{#if ~/paginate !== 'virtual' || ~/meta.bottom}}
  <div class-rtable-bottom {{#if meta.bottomAttrs}}{{yield meta.bottomAttrs}}{{/if}}>
    {{#if ~/meta.bottom}}{{yield meta.bottom with selections.length as selectedCount, rows.length as rowCount, @this as table, selected as selected, selections as selections}}{{/if}}
    {{#if ~/paginate !== 'virtual'}}{{>pagination}}{{/if}}
  </div>
  {{/if}}
</div>

<template id="pagination">
  <div class-rtable-pagination>
    <div class-rtable-info>
      {{#if pagination && rows.length}}{{~/page * ~/pagination.per + 1}} - {{~/page + 1 === ~/pagination.total ? ~/rows.length : (~/page + 1) * ~/pagination.per}} of {{~/rows.length}}{{#if ~/isFiltered}} ({{~/items.length}} total){{/if}}{{/if}}
      {{#if _paginate === 1}}&#x200b;{{/if}}
    </div>
    <div class-rtable-select-all-all>
      {{#if selections.length > 0}}
        <strong>{{selections.length}}</strong> of <strong>{{rows.length}}</strong> selected{{#if @this._allSelected() && selections.length < rows.length}} - <a href="#" on-click="selectAllAll">Select All</a>{{/if}}
      {{/if}}
    </div>
    <div class-rtable-pages>
    {{#if ~/page > 0}}<span on-click="@.set('page', ~/page - 1)">Previous</span>{{/if}}
    {{#each ~/pagination.array}}
      {{#if . == ~/page + 1}}
      <input on-change="(/^\d+$/.test(@node.value) && +@node.value > 0 && +@node.value <= ~/pagination.total && @.set('page', +@node.value - 1)) || @.nodeSet(@node, 'value', ~/page + 1)" value="{{.}}" twoway=false />
      {{elseif . === '...'}}<span on-click="@.set('page', ../[@index - 1])">...</span>
      {{else}}
        <span on-click="@.set('page', . - 1)">{{.}}</span>
      {{/if}}
    {{/each}}
    {{#if ~/page < ~/pagination.total - 1}}<span on-click="@.set('page', ~/page + 1)">Next</span>{{/if}}
    </div>
  </div>
</template>

<template id="empty">
  <div><div>{{message || 'No data.'}}</div></div>
</template>

<template id="csp-dummy">
  <div
    class-rtable-odd="(@index + ~/virtual.offset) % 2 === 1"
    class-top=".valign === 'top'"
    class-bottom=".valign === 'bottom'"
    class-center=".valign === 'center'"
    on-click="@this._setSort(.index, @event)"
    on-click="@this._select(., @event), false"
    on-click="@this._open(., ~/rows.indexOf(.), ~/visibleRows.indexOf(.))"
    on-click="@this._expand(@index)"
    on-click="@event.stopPropagation()"
  />
  {{#if ~/selections.indexOf(.)}}...{{/if}}
  {{#if . === ~/expanded}}...{{/if}}
  {{#if ~/virtual.offset > 0}}...{{/if}}
  {{#if !~/fixedHeader && ~/virtual.offset > 0}}...{{/if}}
  {{#if ~/columns.0.type === 'boolean'}}...{{/if}}
  {{#if @this._allSelected()}}...{{/if}}
</template>

<script>
  import Ractive from 'ractive';
  import { grid, style as gridStyle } from './grid';
  import click from './event-click';
  import expand from './transition-expand';
  import scrolled from './scrolled';
  import { sized } from './watch-size';
  import globalRegister from './globalRegister';

  const sortRE = /^([-+])?([^\s]+)$/;

  function isString(v) { return typeof v === 'string'; }
  function isNumber(v) { return typeof v === 'number'; }
  function isObject(v) { return typeof v === 'object'; }
  function isRegex(v) { return typeof v === 'object' && Object.prototype.toString.call(v) === 'RegExp' }

  export class Table extends Ractive {
    constructor(opts) { super(opts); }

    _allSelected() {
      const sel = this.get('selections');
      const visible = this.get('paginate') === 'virtual' ? this.get('rows') : this.get('visibleRows');

      for (let i = 0; i < visible.length; i++) {
        if (!~sel.indexOf(visible[i])) return false;
      }

      return visible.length && true;
    }

    _setSort(index, ev) {
      const [localh, classh] = [this.get('sort-handler'), this.get('@style.raui.table.sort-handler')];
      const fn = localh || classh;
      if (fn) {
        fn(this, this.get(`columns.${index}`), index, ev);
      } else {
        const sort = this.get('sort') || '';
        const col = this.get(`columns.${index}`);
        const id = col.id;
        if (sort === id || sort.substr(1) === id) {
          if (sort[0] === '-') this.set('sort', id);
          else this.set('sort', `-${id}`);
        } else {
          this.set('sort', id);
        }
      }
    }

    nodeSet(node, prop, value) { node[prop] = value; }

    _expand(idx) {
      const which = this.get('visibleRows')[idx];
      const current = this.get('expanded');
      const expanded = this.find('.rtable-row-expand');
      if (expanded) {
        this.transition('expand', expanded, { outro: true }).then(() => {
          if (current === which) this.set('expanded', null);
          else {
            this.set('expanded', which);
            this.transition('expand', this.find('.rtable-row-expand'), { intro: true });
          }
        });
      } else {
        if (which === current) this.set('expanded', null);
        else {
          this.set('expanded', which);
          this.transition('expand', this.find('.rtable-row-expand'), { intro: true });
        }
      }
    }

    _hover(idx) {
      this.set('hovered', this.get('~/visibleRows')[idx]);
      return false;
    }

    _unhover(idx) {
      if (this.find('.rtable-top .rtable-row-wrap:hover')) return;
      else this.set('hovered', undefined);
      return false;
    }

    _select(src, ev) {
      let sels = this.get('selections');
      if (!sels) {
        sels = [];
        this.set('selections', sels);
      }

      const i = sels.indexOf(src);

      if (~i) this.splice('selections', i, 1);
      else this.push('selections', src);

      if (i >= sels.length || sels.length === 1) this.set('selected', sels[sels.length - 1]);

      this.fire('selection', {}, { item: sels[sels.length - 1], items: sels });

      setTimeout(() => ev.target.checked = !~i);

      return false;
    }

    _open(row, idx, vidx) {
      if (this._opentm) return;
      this.fire('selected', {}, row, idx, vidx);
      this._opentm = setTimeout(() => {
        this._opentm = null;
      }, 500);
    }

    select() {
      const selected = this.get('selected');

      if (selected) {
        this.fire('selected', {}, selected, this.get('rows').indexOf(selected), this.get('visibleRows').indexOf(selected));
      }
    }

    deselect() {
      this.set({
        selections: [],
        selected: undefined
      });
    }

    get selections() { return this.get('selections') || []; }
    set selections(v) {
      const rows = this.get('rows');
      const sels = Array.isArray(v) ? v.filter(i => ~rows.indexOf(i)) : [];
      this.set('selections', sels);
    }

    get selected() { return this.get('selected'); }
    set selected(v) { this.set({ selected: v, selections: [v] }); }

    get rows() { return this.get('rows'); }
    get visibleRows() { return this.get('visibleRows'); }
    get allRows() { return this.get('items'); }

    selectionOffset(offset) {
      const selected = this.get('selected');
      let visible = this.get('visibleRows');
      if (!selected || !~visible.indexOf(selected)) {
        let next = offset > 0 ? visible[0] : visible[visible.length - 1];
        this.set({
          selected: next,
          selections: [next]
        });
      } else {
        const idx = visible.indexOf(selected);
        if (offset > 0 ? idx + offset >= visible.length : idx + offset < 0 ) {
          const move = (offset < 1 ? -1 : 1);
          if ((move < 0 && this.get('page') + move >= 0) || (move > 0 && this.get('page') + move < this.get('pagination.total'))) {
            this.add('page', move);
          }
          visible = this.get('visibleRows');
          const next = offset > 0 ? visible[0] : visible[visible.length - 1];
          this.set({
            selected: next,
            selections: [next]
          });
        } else {
          this.set({
            selected: visible[idx + offset],
            selections: [visible[idx + offset]]
          });
        }
      }

      this.fire('selection', {}, { item: this.get('selected'), items: this.get('selections') });
    }

    selectionDown() {
      this.selectionOffset(1);
    }

    selectionUp() {
      this.selectionOffset(-1);
    }

    _selectGroup(idx) {
      let grp = idx;
      if (this.get('page')) {
        grp += this.get('page') * this.get('pagination.per');
      }
      const rows = this.get('rows');
      const groups = this.get('groups');
      const sels = this.get('selections');
      let x = rows[grp++];
      const xs = ['selections'];
      let ss = [];
      let i;
      if (!~(i = sels.indexOf(x))) xs.push(x);
      else ss.push(i);

      while (grp < rows.length && !(grp in groups)) {
        x = rows[grp++];
        if (!~(i = sels.indexOf(x))) xs.push(x);
        else ss.push(i)
      }

      // select or unselect the things
      if (xs.length === 1) {
        i = ss.length;
        while (i--) {
          this.splice('selections', ss[i], 1);
        }
      } else {
        this.push.apply(this, xs);
      }

      return false;
    }

    _groupSelected(idx) {
      let grp = idx;
      if (this.get('page')) {
        grp += this.get('page') * this.get('pagination.per');
      }
      const rows = this.get('rows');
      const groups = this.get('groups');
      const sels = this.get('selections');
      if (!~sels.indexOf(rows[grp++])) return false;

      while (grp < rows.length && !(grp in groups)) {
        if (!~sels.indexOf(rows[grp++])) return false;
      }

      return true;
    }

    _rows() {
      const src = (this.get('items') || []).slice();
      const filter = this.get('filter');
      const sort = this.get('sort');
      const [localh, classh] = [this.get('data-handler'), this.get('@style.raui.table.data-handler')];
      const handler = localh || classh || defaultFilter;
      if (!filter && !sort) {
        this.set('isFiltered', false);
        return this.set('rows', src);
      }
      const res = handler(this, src, filter, sort, this.get('parameters', { virtual: true }));
      this.set('isFiltered', res.length !== src.length);
      this.set('rows', res);
      const sels = this.get('selections');
      this.set('selections', sels.filter(s => ~src.indexOf(s)));
      if (!~src.indexOf(this.get('selection'))) this.set('selected', undefined);
    }
  }

  function scrollother(node, find) {
    const scroll = ev => {
      requestAnimationFrame(() => this.find(find).scrollLeft = ev.target.scrollLeft);
    }
    node.addEventListener('scroll', scroll, { passive: true });
    return {
      teardown() { node.removeEventListener('scroll', scroll); }
    };
  }

  Table.settings = {
    valign: 'center',
    border: false,
    'fixed-header': true,
    'allow-select': true,
    'allow-select-all': true,
    'auto-titles': false,
    paginate: 'virtual'
  };

  Ractive.extendWith(Table, {
    template: $TEMPLATE,
    css: $CSS,
    cssId: 'rtable',
    noCssTransform: true,
    attributes: ['paginate', 'items', 'filter', 'data-handler', 'sort-handler', 'sort', 'helpers', 'fixed', 'allow-select', 'allow-select-all', 'border', 'fixed-header', 'valign', 'no-header', 'empty', 'shuffle', 'no-wrap', 'parameters'],
    components: {
      table: false,
      Table: false
    },
    syncComputedChildren: true,
    decorators: { grid, sized, scrollother },
    events: {},
    use: [click({ name: 'clickd', count: 1 }), click({ name: 'dblclickd', count: 2 }), expand(), scrolled()],
    on: {
      construct,
      config() {
        this.set(this._init.sets);
        Object.assign(this.partials, this._init.partials);
      },
      render() {
        if (this._autoObserver) this._autoObserver.fire();
      },
      selectAll() {
        let sel, item;
        if (this._allSelected()) {
          item = null;
          sel = [];
          this.set({
            selections: sel,
            selected: item
          });
        } else {
          sel = (this.get('paginate') === 'virtual' ? this.get('rows') : this.get('visibleRows')).slice();
          item = sel[0];
          this.set({
            selections: sel,
            selected: item
          });
        }

        this.fire('selection', {}, { item, items: sel });
        return false;
      },
      selectAllAll() {
        const item = null;
        const sel = this.get('rows').slice();
        this.set({
          selections: sel,
          selected: item
        });
        this.fire('selection', {}, { item, items: sel });
        return false;
      }
    },
    observe: {
      _rows() {
        if (this._rowbounce) clearTimeout(this._rowbounce);
        setTimeout(() => this._rows(), this.get('@style.raui.table.debounce') || 160);
      },
      paginate: {
        handler(v) {
          if (v === 'auto' || v === 'virtual' || v instanceof Ractive) {
            if (this._autoObserver) this._autoObserver.cancel(); // may be changing instances
            if (this._scrollListener) this._scrollListener.cancel();

            const root = v === 'auto' || v === 'virtual' ? this.root : v;
            let sized = false;

            const fn = () => {
              if (!this.rendered) return;
              const top = this.find('.rtable-top');
              if (!top) return;
              if (!this.get('items.length')) {
                if (!this._autoLenObserver) {
                  this._autoLenObserver = this.observeOnce('items', () => {
                    this._autoLenObserver = 0;
                    setTimeout(fn);
                  });
                }
                return;
              }

              const size = `${top.clientHeight},${top.clientWidth}`;
              if (fn.last === size && sized) return;

              {
                const ctx = this.getContext(top);
                if (ctx.decorators && ctx.decorators.scrolled) ctx.decorators.scrolled.refresh();
              }

              const header = this.find('.rtable-header') || {};

              let rows = Array.apply(null, this.findAll('.rtable-live')).map(r => r.offsetHeight);
              if (rows.length < 5) {
                let auto = Math.floor(top.clientHeight / (header.offsetHeight || 1));
                if (auto < 5) auto = 5;
                this.set('_paginate', auto);
                rows = Array.apply(null, this.findAll('.rtable-live')).map(r => r.offsetHeight);
              }
              if (rows.length > 0) sized = true;
              else rows = [25];
              const avg = Math.ceil(rows.reduce((a, c) => a + c, 0) / rows.length);
              this._avgSize = avg;

              let fit = Math.floor((top.clientHeight - (header.offsetHeight || 1)) / avg);
              if (v === 'virtual') {
                fit = fit + 10;
                if (fit < 30) fit = 30;
              }
              this.set('_paginate', fit);

              fn.last = size;
            };

            let tm;
            const fnd = () => {
              if (tm) clearTimeout(tm);
              tm = setTimeout(() => {
                fn();
                tm = null;
                if (sized && this._scrollListener) this._scrollListener.fn();
              }, 50);
            }

            this._autoObserver = this.observe('~/tableHeight', fnd);
            this._autoObserver.fire = fnd;

            if (v === 'virtual') {
              let lock = false;
              let node;
              const fn = () => {
                if (!this.rendered) {
                  node = null;
                  return;
                }
                if (!node) node = this.find('.rtable-top');
                if (!sized) { return fnd(); }

                const top = node.scrollTop;
                const virtual = this.get('virtual') || {};
                let offset = virtual.offset;
                let visible = this.get('_paginate');
                const page = visible - 10;
                const count = this.get('rows.length');
                if (visible > count) visible = count;
                const avg = this._avgSize;
                const pageSize = page * avg;
                let wnd = Math.floor(top / avg);
                let first = wnd - 5;
                if (first < 0) first = 0;
                const hardFirst = first;
                if (first + visible > count) first = count - visible;

                if (offset === first && !isNaN(virtual.top)) return lock = false;
                
                // check to see if the rendered area is approaching an edge
                if (!isNumber(offset) || isNaN(offset) || isNaN(virtual.top) || top < virtual.top + pageSize || top > virtual.bottom - pageSize || offset > 0 && top < avg * page) {
                  let amtAbove = hardFirst;
                  let amtBelow = count - hardFirst - visible;
                  if (amtAbove < 0) {
                    amtBelow += amtAbove * -1;
                    amtAbove = 0;
                  } else if (amtAbove > count - visible) {
                    amtAbove = count - visible;
                  }
                  if (amtBelow < 0) amtBelow = 0;

                  const above = amtAbove * avg;
                  const below = amtBelow * avg;

                  let vis, next;
                  if (first < offset + visible && first > offset - visible) {
                    if (first > offset) vis = this.findAll('.rtable-live')[first - offset];
                    else vis = this.findAll('.rtable-live')[offset - first];
                  }

                  if (vis && first > 0 && vis.offsetTop > node.scrollTop - pageSize - 5 && vis.offsetTop < node.scrollTop + pageSize) next = vis.offsetTop;

                  this.set({
                    'virtual.above': above,
                    'virtual.below': below,
                    'virtual.offset': first
                  });

                  if (typeof next === 'number') {
                    if (next !== vis.offsetTop) this.set('virtual.above', above + (next - vis.offsetTop));
                  }

                  this.set({
                    'virtual.top': this.get('virtual.above'),
                    'virtual.bottom': node.scrollHeight - below
                  });
                }

                lock = false;
              };
              const scroll = this._scrollListener = this.on('scroll', ({ node }) => {
                if (!lock) {
                  lock = true;
                  requestAnimationFrame(fn);
                }
              });
              scroll.fn = fn;

              scroll.observer = this.observe('rows.length', () => {
                this.set('virtual.offset', null);
                fn();
              }, { init: false, strict: true, defer: true });

              const cancel = scroll.cancel;
              scroll.cancel = () => {
                cancel();
                scroll.observer.cancel();
              }
            }

            fnd();
          } else {
            if (this._autoObserver) this._autoObserver.cancel();
            if (this._scrollListener) this._scrollListener.cancel();
          }

          if (isNumber(v)) {
            this.set('_paginate', v);
          }
        },
        defer: true
      },
      'scrollOffset tableHeight': {
        handler() {
          requestAnimationFrame(() => {
            const top = this.find('.rtable-top');
            const ctx = top && this.getContext(top);
            if (ctx && ctx.decorators && ctx.decorators.scrolled) ctx.decorators.scrolled.refresh();
          });
        },
        init: false
      },
      scroll(v, o) {
        if (~(v || '').indexOf('top') && !~(o || '').indexOf('top')) this.fire('scrolltop', {});
        if (~(v || '').indexOf('bottom') && !~(o || '').indexOf('bottom')) this.fire('scrollbottom', {});
      }
    },
    data() {
      return Object.assign({
        page: 0,
        selections: [],
        showGroups: true,
        allowGroupSelect: true,
        expanded: null,
        minPerPage: 10,
        virtual: { offset: 0 },
        shuffle: false,
        rows: [],
      }, Table.settings);
    },
    computed: {
      allowSelect() { return this.get('allow-select'); },
      allowSelectAll() { return this.get('allow-select-all'); },
      fixedHeader() { return this.get('fixed-header'); },
      autoTitles() { return this.get('auto-titles'); },
      noHeader() { return this.get('no-header'); },
      noWrap() { return this.get('no-wrap'); },
      _rows() {
        const src = (this.get('items') || []).slice();
        const filter = this.get('filter');
        const sort = this.get('sort');
        const params = this.get('parameters');
        const [localh, classh] = [this.get('data-handler'), this.get('@style.raui.table.data-handler')];
        const [localp, classp] = [this.get('data-pre-handler'), this.get('@style.raui.table.data-pre-handler')];
        if (localp || classp) (localp || classp)(this, src, filter, sort, params);
        return {};
      },
      visibleRows() {
        const rows = this.get('rows');
        const paginate = this.get('paginate');
        let per = paginate;
        const intPer = this.get('_paginate');
        let offset = this.get('page') || 0;
        const virtual = this.get('virtual');

        if (!per) return rows;

        if (typeof per !== 'number' && isNaN(+per)) {
          if (per === 'auto' || per === 'virtual' || per instanceof Ractive) per = intPer || 1;
          else per = 30; // TODO: virtual table/auto size
        }

        if (per < this.get('minPerPage')) per = this.get('minPerPage');

        if (paginate === 'virtual') {
          offset = (virtual && virtual.offset) || 0;
          return rows.slice(offset, offset + per);
        } else {
          if (offset * per > rows.length) setTimeout(() => this.set('page', 0), 0);
          return rows.slice(per * offset, per * offset + per);
        }
      },
      pagination() {
        const items = this.get('items') || empty;
        const rows = this.get('rows');
        const paginate = this.get('paginate');
        let per = paginate;
        const offset = this.get('page') || 0;

        if (typeof per !== 'number' && isNaN(per)) {
          per = this.get('_paginate');
        }
        if (per < this.get('minPerPage')) per = this.get('minPerPage');

        if (!per) return;

        const total = Math.ceil(rows.length / per);
        const info = {
          max: Math.ceil(items.length / per),
          total,
          per
        };

        if (paginate === 'virtual') {
          info.height = this._avg * rows.length;
        }

        if (info.total > 14) {
          const arr = info.array = [];

          if (offset > 5) arr.push(1, 2, 3, '...');
          else arr.push(1, 2, 3, 4, 5, 6, 7, 8);

          if (offset > 5 && offset + 6 < total) arr.push(offset - 1, offset, offset + 1, offset + 2, offset + 3, '...', total - 2, total - 1, total);
          else if (offset + 6 < total) arr.push('...', total - 2, total - 1, total);
          else arr.push(total - 7, total - 6, total - 5, total - 4, total - 3, total - 2, total - 1, total);
        } else {
          info.array = Array.apply(null, { length: info.total }).map((v, i) => i + 1);
        }

        return info;
      },
      groups() {
        const rows = this.get('rows');
        let last, cur;
        const res = {};
        for (let i = 0; i < rows.length; i++) {
          cur = rows[i][this._init.by];
          if (cur != last) res[i] = 1;
          last = cur;
        }
        return res;
      }
    }
  });

  const notNumbers = /^[^\d]*/;
  export function numberify(v) {
    if (isNumber(v)) return v;
    if (!v) return +Infinity;
    v = `${v}`.replace(notNumbers, '');
    if (!v) return +Infinity;
    return parseFloat(v);
  }

  function columnGetter(table, col, sort) {
    if (typeof col.get === 'function') return col.get;
    const path = (sort ? col.sort : 0) || col.path || col.filter || col.id;
    if (typeof path === 'string') {
      const arr = Ractive.splitKeypath(path);
      return row => {
        let v = row;
        for (let i = 0; i < arr.length; i++) {
          v = v && v[arr[i]];
        }
        return v;
      };
    }
  }

  function defaultFilter(table, rows, filter, sort) {
    const all = [].concat(table.viewmodel.value.columns, table.viewmodel.value.fields);
    const map = all.reduce((a, c) => ((a[c.id] = columnGetter(table, c)) || true) && a, {});
    const cols = Object.values(map);

    let list = rows || [];
    const src = list;

    if ((filter instanceof RegExp || isString(filter)) && filter) {
      const nocase = filter === '' + filter.toLowerCase() || filter === '' + filter.toUpperCase();
      try {
        const re = isString(filter) ? new RegExp(filter, nocase ? 'i' : '') : filter;
        list = list.filter(l => {
          let i = cols.length;
          while (i--) {
            const v = l && cols[i](l);
            if (v && re.test(v)) return true;
          }
        });
      } catch (e) {}
    }

    if (isString(sort) || (isObject(sort) && !Array.isArray(sort))) sort = [sort];

    if (Array.isArray(sort)) {
      sort = sort.map(f => {
        if (isString(f)) {
          const id = f[0] === '-' || f[0] === '+' ? f.substr(1) : f;
          const col = all.find(c => c.id === id);
          if (!col) return;
          const res = { get: columnGetter(table, col, true), dir: f[0] === '-' ? -1 : 1 };
          if (col && col.type === 'number') {
            const get = res.get;
            res.get = function(v) {
              return numberify(get.call(table, v));
            }
          }
          return res;
        } else if (f && typeof f === 'object') {
          const col = all.find(c => c.id === id);
          if (!col) return;
          const res = {
            dir: isNumber(f.dir) ? f.dir : f.dir === 'desc' ? -1 : 1,
            get: columnGetter(table, col, true)
          };
          if (f.type === 'number' || col && col.type === 'number') {
            const get = res.get;
            res.get = function(v) {
              return numberify(get.call(table, v));
            }
          }
          return res;
        }
      }).filter(s => s && s.get);

      list.sort((a, b) => {
        let aa, bb, p;
        for (let i = 0; i < sort.length; i++) {
          aa = sort[i].get.call(table, a);
          bb = sort[i].get.call(table, b);
          p = sort[i].dir * (aa < bb ? -1 : aa > bb ? 1 : 0);

          if (p !== 0) return p;
        }

        return p;
      });
    }

    return list;
  }

  const colAttrs = ['label', 'type', 'filter', 'hidden', 'sort', 'no-pad', 'id', 'editable', 'fixed'];
  const cell = /^[a-z]{1,3}[0-9]+(?:-[0-9]+)?$/;
  const empty = [];
  function construct() {
    // TODO: editable, selection, etc
    const cmp = this.component;
    if ( !cmp ) return;

    let expandEl, hoverEl, groupEl, wrapperEl, rowEl, topEl, bottomEl, mappings;

    const tpl = cmp.template.f || [];
    const attrs = cmp.template.m ? cmp.template.m.slice() : [];
    const t = cmp.template;
    cmp.template = { e: t.e, f: t.f, t: t.t, m: attrs };

    let id = 0;
    function map(attr, partial, plain) {
      if (attr && attr.f && attr.f.length === 1 && attr.f[0].t === 2) {
        const n = `_a${id++}`;
        attrs.push({ t: 13, n, f: attr.f });
        if (plain) return n;
        return partial ? { t: [{ t: 2, r: `~/${n}` }] } : { t: 2, r: `~/${n}` };
      }
      return attr && attr.f;
    }

    function grabColumns(tpl) {
      const columns = [];
      const fields = [];

      tpl.forEach(e => {
        if (e.e === 'column' || e.e === 'col') {
          const col = {};
          const attrs = e.m || empty;
          let attr;
          col.index = columns.length;
          columns.push(col);

          col.content = (e.f || []).filter(e => e.e !== 'edit' && e.e !== 'header');
          col.editP = (e.f || []).find(e => e.e === 'edit');
          if (col.editP) col.editP = col.editP.f;

          attr = attrs.find(a => a.n === 'id');
          if (attr && isString(attr.f)) col.id = attr.f;

          col.label = (e.f || []).find(e => e.e === 'header');
          if (col.label) {
            col.label = col.label.f;
          } else {
            col.label = attrs.find(a => a.n === 'label');
            if (!col.label) col.label = attrs.find(a => a.n === 'header');
            if (col.label && col.label.f) col.label = map(col.label);
          }
          if (!col.label) col.label = '';
          if (!col.id) col.id = col.label;
          if (!Array.isArray(col.label)) col.label = [col.label];

          col.type = attrs.find(a => a.n === 'type');
          if (col.type && col.type.f) col.type = col.type.f;
          if (!col.type) col.type = 'string';

          col.filter = attrs.find(a => a.n === 'filter');
          if (col.filter && col.filter.f) {
            col.filter = map(col.filter);
            if (col.filter.r) col.filter = col.filter.r;
          }

          col.sort = attrs.find(a => a.n === 'sort');
          if (col.sort && col.sort.f) {
            col.sort = map(col.sort);
            if (col.sort.r) col.sort = col.sort.r;
          }

          col.dir = attrs.find(a => a.n === 'dir');
          if (col.dir && col.dir.f) {
            col.dir = map(col.dir);
            if (col.dir.r) col.dir = col.dir.r;
          }

          col.hidden = attrs.find(a => a.n === 'hidden');
          if (col.hidden && col.hidden.f === 0) col.hidden = true;
          else if (col.hidden && isObject(col.hidden.f)) col.hidden = map(col.hidden);
          else col.hidden = false;
          if (isString(col.hidden)) col.hidden = false;

          col.noPad = attrs.find(a => a.n === 'no-pad');
          if (col.noPad && col.noPad.f === 0) col.noPad = 0;
          else if (col.noPad && isObject(col.noPad.f)) col.noPad = map(col.noPad);
          else delete col.noPad;

          col.editable = attrs.find(a => a.n === 'editable');
          if (col.editable && col.editable.f === 0) col.editable = true;
          else if (col.editable && isObject(col.editable.f)) col.editable = map(col.editable);
          else col.editable = false;

          col.valign = attrs.find(a => a.n === 'valign');
          if (col.valign && isObject(col.valign.f)) col.valign = map(col.valign);
          else if (col.valign && typeof col.valign.f === 'string') col.valign = col.valign.f;

          col.fixed = attrs.find(a => a.n === 'fixed');
          if (col.fixed && isObject(col.fixed.f)) col.fixed = { path: map(col.fixed, false, true) };
          else if (col.fixed && typeof col.fixed.f === 'string') col.fixed = col.fixed.f;

          attr = attrs.find(a => a.n === 'get');
          if (attr && attr.f) {
            const name = map(attr, false, true);
            field.get = function(val) {
              const fn = this.get(name);
              return typeof fn === 'function' ? fn.call(this, val) : undefined;
            };
          }

          col.attrs = attrs.filter(a => !~colAttrs.indexOf(a.n));

          // handle inline grid sizes without requiring the class prefix
          col.attrs.forEach((a, i) => {
            if (cell.test(a.n)) {
              col.attrs[i] = { t: 13, n: `class-${a.n}` };
            }
          });
        } else if (e.e === 'field') {
          const field = {};
          const attrs = e.m || empty;
          let a;

          a = attrs.find(a => a.n === 'path');
          if (isString(a)) field.path = a;
          else if (a && a.f) field.path = map(a);

          a = attrs.find(a => a.n === 'value');
          if (a && a.f) field.value = map(a);
          
          a = attrs.find(a => a.n === 'type');
          if (isString(a)) field.type = a;
          else if (a && a.f) field.type = map(a);

          a = attrs.find(a => a.n === 'id');
          if (isString(a.f)) field.id = a.f;

          a = attrs.find(a => a.n === 'dir');
          if (isString(a)) field.dir = a;
          else if (a && isString(a.f)) field.dir = a.f;

          a = attrs.find(a => a.n === 'label');
          if (isString(a)) field.label = a;
          else if (a && a.f) field.label = map(a);

          a = attrs.find(a => a.n === 'get');
          if (a && a.f) {
            const name = map(a, false, true);
            field.get = function(val) {
              const fn = this.get(name);
              return typeof fn === 'function' ? fn.call(this, val) : undefined;
            };
          }

          if (!field.id) field.id = field.label;
          if (!field.path) field.path = field.id;

          fields.push(field);
        }
      });

      return { fields, columns };
    }

    expandEl = tpl.find(e => e.e === 'expand');
    hoverEl = tpl.find(e => e.e === 'hover');
    groupEl = tpl.find(e => e.e === 'group');
    wrapperEl = tpl.find(e => e.e === 'wrapper');
    rowEl = tpl.find(e => e.e === 'row');
    topEl = tpl.find(e => e.e === 'top');
    bottomEl = tpl.find(e => e.e === 'bottom');
    
    this._init = { sets: grabColumns(tpl), partials: {} };
    const columns = this._init.sets.columns;
    this._init.sets['meta.expand'] = expandEl && expandEl.f && expandEl.f.length && expandEl.f;
    this._init.sets['meta.hover'] = hoverEl && hoverEl.f && hoverEl.f.length && hoverEl.f;
    this._init.sets['meta.extra'] = rowEl && rowEl.f && rowEl.f.length && rowEl.f;
    this._init.sets['meta.top'] = topEl && topEl.f && topEl.f.length && topEl.f;
    this._init.sets['meta.topAttrs'] = topEl && topEl.m;
    this._init.sets['meta.bottom'] = bottomEl && bottomEl.f && bottomEl.f.length && bottomEl.f;
    this._init.sets['meta.bottomAttrs'] = bottomEl && bottomEl.m;

    const sortKey = '[_0._setSort(_1,_2)]';

    // aliases for yielders
    const z = [
      { n: 'gridValue', x: { r: '~/gridValue' } },
      { n: 'gridName', x: { r: '~/gridName' } },
      { n: 'gridSize', x: { r: '~/tableWidth' } },
      { n: 'gridMax', x: { r: '~/gridMax' } },
      { n: 'table', x: { r: '@this' } },
    ];

    // build header partial
    const header = [{ t: 7, e: 'div', m: [
      { t: 13, n: 'class-rtable-row-wrap' },
      { t: 13, n: 'class-row-wrap' },
      { t: 13, n: 'class-rtable-header' },
      { t: 4, f: [{ n: 'style-opacity', f: '0', t: 13 }], n: 50, x: { r: ['~/fixedHeader', '~/virtual.offset'] , s: '!_0&&_1>0' } },
      { t: 4, n: 50, r: '~/fixedHeader', f: [{ t: 13, n: 'style-padding-right', f: [{ t: 2, r: '~/scrollOffset' }, 'px'] }] }
    ], f: [{ t: 7, e: 'div', f: columns.filter(c => c.hidden !== true).map((c, cidx) => {
      c.attrsHP = c.attrs.filter(a => a.n !== 'title');
      const div = { t: 7, e: 'div', f: [{ t: 7, e: 'div', f: [{ t: 16, r: `~/columns.${cidx}.label`, c: { r: '.' }, z }] }], m: [{ t: 13, n: 'title', f: c.label }, { t: 16, r: `~/columns.${cidx}.attrsHP`, z }] };
      if (c.type) div.m.push({ t: 13, n: `class-rtable-${c.type}-column` });
      if (c.filter || c.sort) div.m.push({ t: 13, n: 'class-rtable-sortable' }, { t: 4, n: 53, r: `~/columns.${cidx}`, f: [{ t: 70, n: ['click'], f: { r: ['@this', '.index', '@event'], s: sortKey } }] });

      div.m.push({ t: 13, n: 'class-rtable-column' });
      if (c.fixed) {
        const path = c.fixed.path || `~/columns.${cidx}.fixed`;
        div.m.push({ t: 13, n: 'class-rtable-fixed-column', f: [{ t: 2, r: path }] });
        div.m.push({ t: 4, n: 50, x: { r: [`~/noWrap`, path], s: `_0&&typeof _1==='string'` }, f: [{ t: 13, n: 'style-left', f: [{ t: 2, r: path }] }] });
      }
      let res = div;

      if (c.hidden && c.hidden.r) {
        res = { t: 4, n: 51, r: c.hidden.r, f: [div] };
      }

      return res;
    }), 
    m: [
      { t: 13, n: 'class-row' }
    ] }] }];

    // selectall
    header[0].f.unshift({
      t: 4, n: 50, r: '~/allowSelect', f: [{ t: 7, e: 'div', m: [{ t: 13, n: 'class-rtable-select-header' }, { t: 13, n: 'class-rtable-column' }, { t: 13, n: 'title', f: [{ t: 2, r: 'selections.length' }, ' items selected']}, { t: 13, n: 'class-rtable-all-selected', f: [{ t: 2, x: { r: ['@this'], s: '_0._allSelected()' } }] }], f: [{ t: 7, e: 'div', f: [{ t: 4, n: 50, r: '~/allowSelectAll', f: [{ t: 7, e: 'input', m: [{ t: 73, v: 't', f: 'false' }, { t: 13, n: 'type', f: 'checkbox' }, { t: 13, n: 'checked', f: [{ t: 2, x: { r: ['@this'], s: '_0._allSelected()' } }] }, { t: 13, n: 'class-rtable-select' }, { t: 70, n: ['click'], f: 'selectAll' }] }] }], m: [{ t: 70, n: ['clickd'], f: 'selectAll' }] }] }]
    });

    // buld row partial
    const row = [{ t: 7, e: 'div', m: [
      { t: 13, n: 'class-rtable-row-wrap' },
      { t: 13, n: 'class-rtable-odd', f: [{ t: 2, x: { r: ['@index','~/virtual.offset'], s: '(_0+_1)%2===1' } }] },
      { t: 13, n: 'class-row-wrap' },
      { t: 13, n: 'class-rtable-live' },
      { t: 13, n: 'class-rtable-selected', f: [{ t: 2, x: { r: ['~/selections', '.'], s: '~_0.indexOf(_1)' } }] }
    ], f: [{ t: 7, e: 'div', m: [
      { t: 13, n: 'class-row-wrap' },
      { t: 13, n: 'class-rtable-inner-row-wrap' }
    ], f: [{ t: 7, e: 'div', f: columns.filter(c => c.hidden !== true).map((c, cidx) => {
      let content = [{ t: 7, e: 'div', f: [{ t: 16, r: `~/columns.${cidx}.content`, c: { r: '.' }, z }] }];
      if (c.attrs.length) {
        c.attrsP = c.attrs;
        c.attrs = [{ t: 16, r: `~/columns.${cidx}.attrsP`, c: { r: '.' }, z }];
      } else {
        c.attrs = [];
      }
      const attrs = c.attrs;
      if (c.fixed) {
        const path = c.fixed.path || `~/columns.${cidx}.fixed`;
        attrs.push({ t: 13, n: 'class-rtable-fixed-column', f: [{ t: 2, r: path }] });
        attrs.push({ t: 4, n: 50, x: { r: [`~/noWrap`, path], s: `_0&&typeof _1==='string'` }, f: [{ t: 13, n: 'style-left', f: [{ t: 2, r: path }] }] });
      }
      if (c.editable && (c.filter || c.editP)) {
        // TODO: moar types - pick, date, maybe custom via edit tag
        const noclicky = { t: 70, n: ['click', 'mousedown', 'pointerdown', 'MSPointerDown', 'touchstart'], f: { r: ['@event'], s: '[_0.stopPropagation()]' } };
        const editor = [
          { t: 4, n: 50, x: { r: [`~/columns.${cidx}.editP`], s: `Array.isArray(_0)` }, f: [{ t: 7, e: 'div', m: [{ t: 13, n: 'class-rtable-edit' }, noclicky], f: [{ t: 16, r: `~/columns.${cidx}.editP` }] }] },
          { t: 4, n: 50, l:1, x: { r: [`~/columns.${cidx}.type`], s: "_0==='boolean'" }, f: [{ t: 7, e: 'input', m: [{ t: 13, n: 'type', f: 'checkbox' }, { t: 13, n: 'checked', f: [{ t: 2, r: c.filter }] }, noclicky] }] },
          { t: 4, n: 51, l: 1, f: [{ t: 7, e: 'input', m: [{ t: 13, n: 'value', f: [{ t: 2, r: c.filter }] }, noclicky] }] }
        ];
        if (typeof c.editable === 'object') {
          attrs.push({ t: 13, n: 'class-rtable-editing', f: c.editable });
          content = [
            Object.assign({}, c.editable, { t: 4, n: 50, f: editor }),
            { t: 4, n: 51, l: 1, f: content }
          ]
        } else {
          attrs.push({ t: 13, n: 'class-rtable-editing' });
          content = editor;
        }
      }

      if (c.valign) {
        attrs.push(
          { t: 13, n: 'class-rtable-valign-col-top', f: [{ t: 2, x: { r: [`~/columns.${cidx}.valign`], s: `_0==='top'` } }] },
          { t: 13, n: 'class-rtable-valign-col-bottom', f: [{ t: 2, x: { r: [`~/columns.${cidx}.valign`], s: `_0==='bottom'` } }] },
          { t: 13, n: 'class-rtable-valign-col-center', f: [{ t: 2, x: { r: [`~/columns.${cidx}.valign`], s: `_0==='center'` } }] },
        );
      }

      const div = { t: 7, e: 'div', f: content, m: attrs };
      if (c.type) attrs.unshift({ t: 13, n: `class-rtable-${c.type}-column` });
      attrs.push({ t: 13, n: 'class-rtable-column' });

      const title = c.attrsP && c.attrsP.find(a => a.n === 'title');
      if (!title) attrs.unshift({ t: 4, n: 50, r: '~/autoTitles', f: [{ t: 13, n: 'title', f: c.content.find(e => e.e) ? c.label : c.content }] });
      else if (!title.f) {
        attrs.unshift({ t: 13, n: 'title', f: c.content.find(e => e.e) ? c.label : c.content });
        c.attrsP.splice(attrs.indexOf(title), 1);
      }

      if (c.noPad === 0) attrs.push({ t: 13, n: 'class-rtable-no-pad' });
      else if (c.noPad) attrs.push({ t: 13, n: 'class-rtable-no-pad', f: c.noPad });
      let res = div;

      if (c.hidden && c.hidden.r) {
        res = { t: 4, n: 51, r: c.hidden.r, f: [div] };
      }

      return res;
    }), m: [
      { t: 13, n: 'class-row' }, { t: 13, n: 'class-rtable-row' },
      { t: 70, n: (expandEl && expandEl.f ? ['dblclickd'] : ['click', 'dblclick']), f: { r: ['@this', '~/rows', '~/visibleRows', '.'], s: `[_0._open(_3,_1.indexOf(_3),_2.indexOf(_3))]` } }
    ] }] }] }];

    // extra row attrs
    if (rowEl && rowEl.m && rowEl.m.length) {
      this._init.sets.rowAttrs = rowEl.m.slice();
      row[0].f[0].f[0].m.push({ t: 16, r: '~/rowAttrs', c: { r: '.' }, z });
    }

    // extra wrapper attrs
    if (wrapperEl && wrapperEl.m && wrapperEl.m.length) {
      this._init.sets.wrapperAttrs = wrapperEl.m.slice();
      row[0].m.push({ t: 16, r: '~/wrapperAttrs', c: { r: '.' }, z });
    }

    // extra fixed content
    if (rowEl && rowEl.f && rowEl.f.length) {
      row[0].f[0].f.push({ t: 7, e: 'div', m: [{ t: 13, n: 'class-rtable-row-extra' }, { t: 4, n: 50, r: '~/noWrap', f: [{ t: 13, n: 'style-width', f: [{ t: 2, x: { r: ['~/tableWidth', '~/allowSelect', '@style.raui.table.selectWidth'], s: `_1?'calc('+_0+'px - '+(_2||'2em')+')':_0+'px'` } }] }] }], f: [{ t: 16, r: '~/meta.extra', c: { r: '.' }, z }] });
    }

    // expando rows
    if (expandEl && expandEl.f && expandEl.f.length) {
      const listener = { t: 70, n: ['clickd'], f: { r: ['@this', '@index'], s: '[_0._expand(_1)]' } };
      let ev = expandEl.m && expandEl.m.find(a => a.n === 'skip');
      if (ev && ev.f && ev.f[0] && ev.f[0].t === 2) ev = Object.assign({}, ev.f[0], { t: 4, n: 51, f: [listener] }); // unless {{skip}} listener
      else ev = listener;
      row[0].f[0].f.push({ t: 4, n: 50, x: { r: ['.', '~/expanded'], s: '_0===_1' }, f: [
        { t: 7, e: 'div', f: [{ t: 7, e: 'div', f: [{ t: 16, r: `~/meta.expand`, c: { r: '.' }, z }] }], m: [{ t: 13, n: 'class-rtable-row-expand' }, { t: 4, n: 50, r: '~/noWrap', f: [{ t: 13, n: 'style-width', f: [{ t: 2, x: { r: ['~/tableWidth', '~/allowSelect', '@style.raui.table.selectWidth'], s: `_1?'calc('+_0+'px - '+(_2||'2em')+')':_0+'px'` } }] }] }] }
      ] });
      row[0].f[0].f[0].m.push(ev);
      row[0].f[0].f[1].f[0].m.push({ t: 70, n: ['click'], f: { r: ['@this', '@index'], s: '[_0._expand(_1)]' } });
    }

    // row hover
    if (hoverEl && hoverEl.f && hoverEl.f.length) {
      row[0].f[0].f.unshift({ t: 4, n: 50, x: { r: ['.', '~/hovered'], s: '_0===_1' }, f: [
          { t: 7, e: 'div', f: [{ t: 7, e: 'div', m: [{ t: 13, n: 'class-rtable-row-hover-content' }].concat(hoverEl.m || []), f: [{ t: 16, r: '~/meta.hover', c: { r: '.' }, z }] }], m: [{ t: 13, n: 'class-rtable-row-hover' }, { t: 4, n: 50, r: '~/noWrap', f: [{ t: 13, n: 'style-width', f: [{ t: 2, x: { r: ['~/tableWidth', '~/allowSelect', '@style.raui.table.selectWidth'], s: `_1?'calc('+_0+'px - '+(_2||'2em')+')':_0+'px'` } }] }] }] }
      ] });
      row[0].m.push(
        { t: 70, n: ['mouseenter'], f: { r: ['@this', '@index'], s: '[_0._hover(_1)]' } },
        { t: 70, n: ['mouseleave'], f: { r: ['@this', '@index'], s: '[_0._unhover(_1)]' } },
      );
    }

    // select
    row[0].f.unshift({
      t: 4, n: 50, r: '~/allowSelect', f: [{ t: 7, e: 'div', m: [{ t: 13, n: 'class-rtable-select-row' }, { t: 13, n: 'class-rtable-column' }, { t: 70, n: ['clickd'], f: { r: ['@this', '.', '@event'], s: '[_0._select(_1,_2),false]' } }], f: [{ t: 7, e: 'div', f: [{ t: 7, e: 'input', m: [{ t: 73, v: 't', f: 'false' }, { t: 13, n: 'type', f: 'checkbox' }, { t: 13, n: 'checked', f: [{ t: 2, x: { r: ['~/selections', '.'], s: '~_0.indexOf(_1)' } }] }, { t: 13, n: 'class-rtable-select' }, { t: 70, n: ['click'], f: { r: ['@this', '.', '@event'], s: '[_0._select(_1,_2),false]' } }] }] }] }]
    });

    // group
    let by;
    if (groupEl && groupEl.m && (by = groupEl.m.find(a => a.n === 'by')) && (isString(by.f) || (by.length === 1 && by[0].t === 2))) {
      const group = {
        t: 4, n: 50, f: [{
          t: 7, e: 'div', m: [
            { t: 13, n: 'class-row' }, { t: 13, n: 'class-rtable-group' },
            { t: 13, n: 'class-rtable-selected', f: [{ t: 2, x: { r: ['~/selections', '.'], s: '~_0.indexOf(_1)' } }] },
            { t: 70, n: (expandEl && expandEl.f ? ['dblclickd'] : ['click', 'dblclick']), f: { r: ['~/rows', '~/visibleRows', '.'], s: `[['selected',_2,_0.indexOf(_2),_1.indexOf(_2)]]` } }
          ].concat(groupEl.m.filter(a => a.n !== 'by' && a.n !== 'select'))
        }],
        x: { s: `_0&&_1[(_1&&(_2*_3+_4))||_4]`, r: [ '~/showGroups', '~/groups', '~/page', '~/pagination.per', '@index' ] }
      };
      row.unshift(group);
      this._init.by = by.f;

      const parts = grabColumns(groupEl.f).columns.filter(c => c.hidden !== true).map(c => {
        const div = { t: 7, e: 'div', f: [{ t: 7, e: 'div', f: c.content }], m: c.attrs };
        if (c.type) div.m.unshift({ t: 13, n: `class-rtable-${c.type}-column` });
        div.m.push({ t: 13, n: 'class-rtable-column' });
        if (!div.m.find(a => a.n === 'title')) div.m.unshift({ t: 13, n: 'title', f: c.content });
        let res = div;

        if (c.hidden && c.hidden.r) {
          res = { t: 4, n: 51, r: c.hidden.r, f: [div] };
        }

        return res;
      });

      // select
      parts.unshift({
        t: 4, n: 50, r: '~/allowGroupSelect', f: [{ t: 7, e: 'div', m: [{ t: 13, n: 'class-rtable-select-row' }, { t: 13, n: 'class-rtable-column' }, { t: 70, n: ['clickd'], f: { r: ['@this', '@index'], s: '[_0._selectGroup(_1),false]' } }, { t: 13, n: 'class-rtable-all-selected', f: [{ t: 2, x: { r: ['@this', '@index'], s: '_0._groupSelected(_1)' } }] }], f: [{ t: 7, e: 'div', f: [{ t: 7, e: 'input', m: [{ t: 73, v: 't', f: 'false' }, { t: 13, n: 'type', f: 'checkbox' }, { t: 13, n: 'checked', f: [{ t: 2, x: { r: ['@this', '@index'], s: '_0._groupSelected(_1)' } }] }, { t: 13, n: 'class-rtable-select' }, { t: 70, n: ['click'], f: { r: ['@this', '@index'], s: '[_0._selectGroup(_1),false]' } }] }] }] }]
      });

      
      let attr;
      if (attr = groupEl.m.find(a => a.n === 'select')) {
        (mappings || (mappings = [])).push(Object.assign({}, attr, { n: 'allowGroupSelect' }));
      }

      if (attr = groupEl.m.find(a => a.n === 'show')) {
        (mappings || (mappings = [])).push(Object.assign({}, attr, { n: 'showGroups' }));
      }

      group.f[0].f = parts;
    }

    this._init.partials['grid-row'] = row;
    this._init.partials['grid-head'] = header;

    if (mappings && this.component) this.component.mappings = mappings;
  }

  export function plugin(opts = {}) {
    return function({ Ractive, instance }) {
      if ('includeGrid' in opts) Ractive.styleSet('table.includeGrid', opts.includeGrid);
      instance.components[opts.name || 'data-table'] = Table;
    }
  }

  globalRegister('RMTable', 'components', Table);

  export default plugin;
</script>

<script rel="css">
  const primary = Object.assign({}, data(`raui.primary`), data(`raui.table.primary`));
  const active = Object.assign({}, primary, data('raui.primary.active'), data('raui.table.primary.active'));
  const table = Object.assign({ selected: {}, header: {}, footer: {} }, data('raui.table'));
  return `
  .rtable {
    display: flex;
    flex-direction: column;
    overflow: auto;
    max-width: 100%;
    max-height: 100%;
    box-sizing: border-box;
    flex-grow: 2;
  }

  .rtable.rtable-border {
    border: 1px solid ${table.divider || primary.bc || '#ccc'};
  }

  .rtable-header {
    min-height: 2em;
  }

  .rtable-group > div > div,
  .rtable-header > div > div,
  .rtable-row > div > div {
    padding: ${table.padding || '0.5em'};
    overflow: inherit;
    text-overflow: inherit;
    line-height: 1em;
  }
  .rtable-row > .rtable-no-pad > div {
    padding: 0;
  }

  .rtable-auto .row > *,
  .rtable-fixed .row > *
  {
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }

  .rtable-header > div > div, .rtable-column {
    overflow: hidden;
  }

  .rtable-number-column {
    text-align: right;
  }
  .rtable-date-column {
    text-align: right;
  }

  .rtable-sortable {
    cursor: pointer;
    user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-user-select: none;
  }

  .grid .row.rtable-row, .grid .rtable-header > .row {
    width: auto;
    min-width: min-content;
    flex-grow: 1;
  }

  .rtable-nowrap .grid .rtable-row, .rtable-nowrap .grid .rtable-header > .row {
    flex-wrap: nowrap;
  }
  .rtable-nowrap .rtable-row-wrap, .rtable-inner-row-wrap {
    flex-grow: 1;
  } 

  .rtable-row-wrap {
    display: flex;
    flex-grow: 1;
    align-items: center;
    z-index: 2;
    align-items: stretch;
    color: ${primary.fg || '#222'};
    background-color: ${table.even || primary.bga || '#f4f4f4'};
  }
  .rtable-row-wrap.rtable-odd {
    background-color: ${table.odd || primary.bg || '#fff'};
  }
  .rtable-row-wrap.row-wrap:hover {
    z-index: 10;
  }
  .rtable-row-wrap:hover .rtable-inner-row-wrap, .rtable-row-wrap:hover .rtable-select-row {
    background-color: ${table.over || active.bg || '#e6f0fa'};
  }
  .rtable-row-wrap:hover .rtable-inner-row-wrap,
  .rtable-wrap .rtable-row-wrap:hover .rtable-select-row {
    position: relative;
  }
  .rtable-row-wrap:hover .rtable-select-row {
    z-index: 2;
    overflow: visible;
  }

  .rtable-row-wrap:hover .rtable-inner-row-wrap:after, .rtable-row-wrap:hover .rtable-select-row:after {
    content: ' ';
    position: absolute;
    width: 100%;
    left: 0;
    bottom: -4px;
    background-color: ${table.divider || primary.bc || '#ccc'};
    height: 4px;
  }

  .rtable-row-wrap.rtable-selected {
    background-color: ${table.selected.bg || '#cee5fd'};
    color: ${table.selected.fg || primary.fg || '#222'};
  }
  .rtable-row-wrap.rtable-selected.rtable-odd {
    background-color: ${table.selected.odd || '#c5dffb'};
  }

  .rtable-nowrap .rtable-row-wrap {
    display: inline-flex;
    min-width: 100%;
    box-sizing: border-box;
  }

  .rtable-nowrap > .rtable-top > .grid {
    line-height: 1em;
  }

  .rtable-border .rtable-row .rtable-column,
  .rtable-border .rtable-group .rtable-column {
    border-color: ${table.divider || primary.bc || '#ccc'};
    border-style: solid;
    border-width: 0 0 0 1px;
    margin: 0 0 0 -1px;
  }
  .rtable-wrap.rtable-border .rtable-row .rtable-column,
  .rtable-border .rtable-group .rtable-column {
    border-width: 0 0 1px 1px;
    margin: 0 0 -1px -1px;
  }

  .rtable-border .rtable-header .rtable-column {
    border-width: 0 0 0 0;
    margin: 0 0 0 0;
  }
  .rtable-wrap.rtable-border .rtable-header .rtable-column {
    border-width: 0 0 1px 0;
    margin: 0 0 -1px 0;
  }

  .rtable-border .rtable-row .rtable-column:nth-child(1),
  .rtable-border .rtable-group .rtable-column:nth-child(1) {
    border-left-width: 0;
  }
  .rtable-border.rtable-with-select .rtable-row .rtable-column:nth-child(1),
  .rtable-border.rtable-with-select .rtable-group .rtable-column:nth-child(1) {
    border-left-width: 1px;
  }

  .rtable-border .rtable-row-wrap {
    border-bottom-width: 1px;
  }

  .rtable-border .rtable-row-expand, .rtable-border .rtable-row-extra {
    border-color: ${table.divider || primary.bc || '#ccc'};
    border-style: solid;
    border-width: 1px 0 0 0;
    margin-left: -1px;
    width: 100%;
  }
  .rtable-border.rtable-with-select .rtable-row-expand, .rtable-border.rtable-with-select .rtable-row-extra {
    border-left-width: 1px;
  }

  .rtable-row-expand, .rtable-row-extra {
    box-sizing: border-box;
    padding: ${table.padding || '0.5em'};
  }

  .rtable-row-hover {
    pointer-events: none;
    position: relative;
    z-index: 1;
  }
  .rtable-row-hover-content {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
  }
  .rtable-row-hover-content > * {
    pointer-events: visible;
  }

  .rtable-group {
    border-bottom: 2px solid ${table.divider || primary.bc || '#ccc'};
  }

  .rtable-header.rtable-row-wrap, .rtable-header.rtable-row-wrap:hover {
    font-weight: bold;
    background-color: ${table.header.bg || '#dedede'};
  }
  .rtable-header-fixed {
    line-height: 1em;
    background-color: ${table.header.bg || '#dedede'};
  }

  .rtable-header.rtable-row-wrap, .rtable-header-extra.rtable-noheader {
    border-bottom: 2px solid ${table.divider || primary.bc || '#ccc'};
  }

  .rtable-header-extra {
    background-color: ${table.header.bg || '#dedede'};
    padding: ${table.padding || '0.5em'};
    line-height: 1em;
    z-index: 4;
    box-sizing: border-box;
    min-width: 100%;
  }
  .rtable-nowrap .rtable-header-extra {
    position: sticky;
    left: 0;
  }

  .rtable-top {
    flex-grow: 5;
    flex-shrink: 1;
    overflow-y: auto;
    position: relative;
  }
  .rtable-fixed-header .rtable-header {
    position: relative;
    z-index: 3;
  }
  .rtable-fixed-header.rtable-scrolled-down .rtable-header-fixed {
    box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15), 0 0.25em 0.5em rgba(0,0,0,0.25);
    z-index: 3;
  }
  .rtable-fixed-header .rtable-top {
    margin-top: 0;
  }
  .rtable-nowrap.rtable-fixed-header .rtable-header-wrapper {
    flex-shrink: 0;
    width: 100%;
    overflow-x: auto;
    scrollbar-width: none;
  }
  .rtable-nowrap.rtable-fixed-header .rtable-header-wrapper::-webkit-scrollbar {
    height: 0;
  }
  .rtable-fixed-header .rtable-header-fixed::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .rtable-nowrap .rtable-fixed-column, .rtable-nowrap .rtable-row-extra, .rtable-nowrap .rtable-row-expand, .rtable-nowrap .rtable-row-hover {
    position: -webkit-sticky;
    position: sticky;
    left: 0;
  }
  .rtable-border..rtable-nowrap .rtable-fixed-column, .rtable-border.rtable-nowrap .rtable-row-extra, .rtable-border.rtable-nowrap .rtable-row-expand, .rtable-nowrap .rtable-row-hover  {
    left: 1px;
   }
  .rtable-nowrap.rtable-with-select .rtable-fixed-column, .rtable-nowrap.rtable-with-select .rtable-row-extra, .rtable-nowrap.rtable-with-select .rtable-row-expand, .rtable-nowrap .rtable-row-hover  {
    left: ${table.selectWidth || '2em'};
  }
  .rtabe-border.rtable-nowrap.rtable-with-select .rtable-fixed-column, .rtabe-border.rtable-nowrap.rtable-with-select .rtable-row-extra, .rtabe-border.rtable-nowrap.rtable-with-select .rtable-row-expand, .rtable-nowrap .rtable-row-hover  {
    left: ${table.selectWidth || '2em'};
  }

  .rtable-nowrap .rtable-inner-row-wrap {
    background-color: inherit;
  }

  .rtable-nowrap .row,
  .rtable-nowrap .rtable-fixed-column,
  .rtable-nowrap .rtable-select-row,
  .rtable-nowrap .rtable-select-header {
    background-color: inherit;
    z-index: 1;
  }

  .rtable-nowrap .rtable-select-row,
  .rtable-nowrap .rtable-select-header {
    position: sticky;
    position: -webkit-sticky;
    left: 0;
    z-index: 1;
  }
  .rtable-nowrap .rtable-select-header {
    z-index: 2;
  }

  .rtable-nowrap.rtable-border .rtable-fixed-column {
    border-right-width: 1px;
  }

  .rtable-scrolled-up .rtable-bottom {
    box-shadow: 0 -1px 2px 0 rgba(60, 64, 67, 0.3), 0 -1px 3px 1px rgba(60, 64, 67, 0.15), 0 -0.25em 0.5em rgba(0,0,0,0.25);
    z-index: 3;
  }
  .rtable-bottom {
    padding: ${table.padding || '0.5em'};
    background-color: ${table.footer.bg || table.header.bg ||  '#dedede'};
    border-top: 2px solid ${table.divider || primary.bc || '#ccc'};
  }

  .rtable-pagination {
    display: flex;
    flex-wrap: wrap;
    flex-shrink: 0;
    justify-content: space-between;
    user-select: none;
  }

  .rtable-pages span {
    margin: 0.3em;
    cursor: pointer;
  }
  .rtable-pages span:first-of-type {
    margin-left: 0;
  }
  .rtable-pages input {
    text-align: center;
    width: 2.5em;
    font-size: 1em;
    background-color: transparent;
    border: none;
    padding: 0;
    font-weight: bold;
    text-decoration: underline;
  }

  /* checkboxes */
  .rtable-select {
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    position: absolute;
    display: block;
    margin: 0;
    width: 2em;
    height: 2em;
    box-shadow: none;
    outline: none;
    opacity: 0;
    top: -4px;
    left: -1.5px;
    border-radius: 2em;
    transition: transform 0.2s, opacity 0.2s;
    background-color: ${primary.bc || '#ccc'};
    cursor: pointer;
  }

  .rtable-select-header > div, .rtable-select-row > div, .rtable-header > div.rtable-select-header > div {
    padding: 0;
    overflow: visible;
    width: 1.5em;
    position: relative;
    line-height: 1.8em;
    cursor: pointer;
    display: flex;
    justify-content: space-around;
    align-items: center;
    flex-grow: 0;
  }

  .rtable-select:checked {
    background-color: ${primary.fga || '#07e'};
  }

  .rtable-select-header:hover .rtable-select, .rtable-select-row:hover .rtable-select {
    opacity: 0.04;
  }

  .rtable-select:focus {
    opacity: 0.12;
    transform: scale(1);
  }

  .rtable-select-header:hover .rtable-select:focus, .rtable-select-row:hover .rtable.select:focus {
    opacity: 0.16;
  }

  .rtable-select:active {
    opacity: 0.4;
    transform: scale(0);
    transition: transform 0s, opacity 0s;
  }

  .rtable-select-row > div:before, .rtable-select-header > div:before {
    content: "";
    display: inline-block;
    box-sizing: border-box;
    border: solid 2px; /* Safari */
    border-color: ${primary.fg || '#222'};
    border-radius: 2px;
    width: 18px;
    height: 18px;
    vertical-align: middle;
    transition: border-color 0.2s, background-color 0.2s;
  }

  .rtable-select-row > div:after, .rtable-select-header > div:after {
    content: "";
    display: block;
    position: absolute;
    top: -5px;
    left: 0px;
    width: 10px;
    height: 5px;
    border: solid 2px transparent;
    border-right: none;
    border-top: none;
    transform: translate(0.35em, 0.55em) rotate(-45deg);
    opacity: 0;
  }

  .rtable-selected .rtable-select-row > div:before, .rtable-all-selected > div:before {
    border-color: ${primary.fga || '#07e'};
    background-color: ${primary.fga || '#07e'};
  }

  .rtable-selected .rtable-select-row > div:after, .rtable-all-selected > div:after {
    border-color: ${primary.bg || '#fff'};
    opacity: 1;
  }

  .rtable-row-wrap > .rtable-select-header,
  .rtable-row-wrap > .rtable-select-row {
    text-align: center;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-around;
    width: ${table.selectWidth || '2em'};
  }
  
  .rtable-row-wrap > .rtable-select-row {
    border-style: solid;
    border-color: ${table.divider || primary.bc || '#ccc'};
    border-width: 0 0 1px 0;
  }

  .rtable-inner-row-wrap {
    border-style: solid;
    border-color: ${table.divider || primary.bc || '#ccc'};
    border-width: 0 0 1px 0;
  }

  .rtable-column button, .rtable-column .btn {
    padding: 0 0.5em;
    margin: 0.2em 0.5em;
    min-height: 0;
  }

  .rtable-column.rtable-editing, .rtable-column.rtable-editing > .rtable-edit  {
    padding: 0;
  }
  .rtable-column.rtable-editing input {
    width: 100%;
    box-sizing: border-box;
    height: 100%;
    margin: 0;
    border: none;
    background-color: transparent;
    padding: 0.25em 0.5em;
  }

  .rtable-valign-top .rtable-row:not(.rtable-header) .rtable-column > div,
  .rtable .rtable-row:not(.rtable-header) > .rtable-column.rtable-valign-col-top > div {
    display: flex;
    height: 100%;
    align-items: flex-start;
    box-sizing: border-box;
  }
  .rtable-valign-bottom .rtable-row:not(.rtable-header) .rtable-column > div,
  .rtable .rtable-row:not(.rtable-header) > .rtable-column.rtable-valign-col-bottom > div {
    display: flex;
    height: 100%;
    align-items: flex-end;
    box-sizing: border-box;
  }
  .rtable-valign-center .rtable-row:not(.rtable-header) .rtable-column > div,
  .rtable .rtable-row:not(.rtable-header) > .rtable-column.rtable-valign-col-center > div {
    display: flex;
    height: 100%;
    align-items: center;
    box-sizing: border-box;
  }
  ` + (data('table.includeGrid') ? gridStyle(data) : '');
</script>
