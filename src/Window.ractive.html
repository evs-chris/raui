<div class-rwhost as-tracked=`host` {{yield extra-attributes}}>
  {{#if ~/currentMax && ~/_maxP}}
  <div class-rwindow-max-top {{#if ~/_maxAttrsP}}{{yield ~/_maxAttrsP}}{{/if}}>{{yield ~/_maxP with ~/current as window, { t: @this.partials.windowControls } as windowControls, @this as host }}</div>
  {{/if}}
  <div class-rwhost-pane class-rwhost-blocked="~/blocked">
    <div class-rwhost-pane-content>
      {{yield}}
    </div>
    {{#each @.children.byName.window}}
    <#window control="{{~/windows[.instance.id]}}" bind-root="~/" />
    {{/each}}
    <div class-rwhost-modal as-tracked=`modalPane` {{#if ~/blocked}}class-rwhost-modal-active style-z-index="{{~/blocked}}"{{/if}} />
  </div>
  {{>toast}}
</div>

<template id="window">
  {{#if ~/control.show}}
  <div class-rwindow-wrapper as-tracked=`wrapper`
    {{#if (~/root.max || ~/root.userMax || ~/control.max) && !~/control.dialog && !~/control.slide}}
      {{#if ~/root.transition !== false}}window-out{{/if}}
      {{#unless ~/control.autosize || ~/control.dialog}}style-top="0" style-left="0" style-width="100%" style-height="100%"{{/unless}}
      class-rwindow-max
    {{elseif ~/control.slide}}
      class="rwindow-slide rwindow-slide-{{~/control.slide}}" slide-in-out="{ from: ~/control.slide }"
    {{else}}
      {{#if ~/root.transition !== false}}modal-in-out{{/if}}
      {{#if ~/control.resizable}}
        class-rwindow-resizable
        on-mousedown-touchstart="@._startResize(@event)"
        on-mousemove-mouseout="@._sizeHandle(@event)"
      {{/if}}
      {{#if ~/control.resizing}}class-rwindow-resizing{{/if}}
      style-top="{{~/control.top}}px" style-left="{{~/control.left}}px"
      {{#unless ~/control.autosize}}style-width="{{~/control.width}}em" style-height="{{~/control.height}}em"{{/unless}}
    {{/if}}
    style-z-index="{{~/control.index}}"
    class-rwindow-topmost="~/control.topmost"
  >
    <div class-rwindow
      {{#if !(~/control.movable === false || ((~/root.max || ~/root.userMax) && !~/control.dialog) || ~/control.max) && (!~/control.dialog || ~/control.movable === true) && !~/control.slide}}
        on-mousedown-touchstart="@._startMove(@event)"
      {{elseif !~/control.topmost}}
        on-mousedown-touchstart="@.raise()"
      {{/if}}
    >
      <div class-rwindow-modal class-rwindow-blocked="~/control.blockers.length || ~/control.blocked"></div>
      <div class-rwindow-pane as-tracked=`pane` {{#if ~/control.autosize && !~/control.slide}}class-rwindow-autosizing{{/if}}>
        {{>pane}}
      </div>
    </div>
  </div>
  {{/if}}
</template>

<template id="pane">
  {{#if !((~/control.max || ~/root.userMax || ~/root.max) && ~/root.hideTitleMax && !~/control.dialog) && !~/control.hideTitle && !~/control.slide}}
  <div class-rwindow-pane-top as-tracked=`top`>
    {{>title}}
    <div class-rwindow-controls>
      {{#if !~/control.dialog && ~/control.minimize}}<div class-rwindow-minimize on-click="@.hide()"></div>{{/if}}
      {{#if !~/control.dialog && ~/control.maximize}}<div class-rwindow-maximize on-click="@.maximize()"></div>{{/if}}
      {{#if ~/control.close}}<div class-rwindow-close on-click="@.close()"></div>{{/if}}
    </div>
  </div>
  {{/if}}
  <div class-rwindow-content as-tracked=`content` class-rwindow-pad="~/control.pad" class-rwindow-flex="~/control.flex" {{#if ~/control.autosize}}style-overflow=visible{{/if}}>{{>contents}}</div>
  {{#if ~/buttons}}
    <div class-rwindow-buttons class-no-buttons="!~/visibleButtons">
      <div class-rwindow-left-buttons>{{#each ~/leftButtons}}{{#if .partial}}{{>.partial}}{{else}}<button as-button on-click=".action.call(@)" {{#if .class}}class="{{.class}}"{{/if}}>{{.label}}</button>{{/if}}{{/each}}</div>
      <div class-rwindow-center-buttons>{{#each ~/centerButtons}}{{#if .partial}}{{>.partial}}{{else}}<button as-button on-click=".action.call(@)" {{#if .class}}class="{{.class}}"{{/if}}>{{.label}}</button>{{/if}}{{/each}}</div>
      <div class-rwindow-right-buttons>{{#each ~/rightButtons}}{{#if .partial}}{{>.partial}}{{else}}<button as-button on-click=".action.call(@)" {{#if .class}}class="{{.class}}"{{/if}}>{{.label}}</button>{{/if}}{{/each}}</div>
    </div>
  {{/if}}
  <div class-rwindow-pane-bottom>
    {{>status}}
  </div>
</template>

<template id="windowControls">
  <div class-rwindow-controls>
    {{#if !window.dialog && window.minimize}}<div class-rwindow-minimize on-click="host.getWindow(window.id).hide()"></div>{{/if}}
    {{#if !window.dialog && window.maximize && host.data.userMax}}<div class-rwindow-maximize on-click="host.getWindow(window.id).maximize()"></div>{{/if}}
    {{#if window.close}}<div class-rwindow-close on-click="host.getWindow(window.id).close()"></div>{{/if}}
  </div>
</template>

<template id="title">
  {{#if ~/control.title}}<div class-rwindow-title>{{{~/control.title}}}</div>{{/if}}
</template>

<template id="contents"></template>
<template id="status"></template>

<script>
  import Ractive from 'ractive';
  import expand from './transition-expand';
  import toast from './Toast';
  import globalRegister from './globalRegister';
  import { sizeInEm, sizeInPx } from './watch-size';

  const escape = Ractive.escapeKey;
  let windowTrans;

  export class Base extends Ractive {
    constructor(opts) { super(opts); }
  }

  Ractive.extendWith(Base, {
    css: $CSS,
    cssId: 'rwindow',
    noCssTransform: true,
    delegate: false,
    decorators: {
      tracked(node, id) {
        this[id] = node;
        return {
          teardown() { if (this[id] === node) this[id] = null; }
        };
      }
    },
    transitions: {
      window(t, params) {
        if (windowTrans) return t.complete();

        windowTrans = t;

        const p = t.processParams(params, { duration: 400, easing: 'easeInOut' });
        const parent = t.node.parentNode;
        const overflow = parent.style ? parent.style.overflow : '';

        if (parent.style) parent.style.overflow = 'hidden';
        if (t.isIntro || p.intro) {
          t.setStyle({
            transform: 'translate(30%, 0px) scale(1.1, 1.1)',
            opacity: 0
          });
          setTimeout(() => {
            t.animateStyle({
              transform: 'none',
              opacity: 1
            }, p).then(() => {
              t.setStyle('opacity', 1);
              windowTrans = false;
              t.complete();
              if (parent.style) parent.style.overflow = overflow;
            });
          });
        } else {
          t.setStyle({
            transform: 'none',
            opacity: 1
          });
          t.animateStyle({
            transform: 'translate(30%, 0px) scale(1.1, 1.1)',
            opacity: 0
          }, p).then(() => {
            windowTrans = false;
            t.complete();
            if (parent.style) parent.style.overflow = overflow;
          });
        }
      },
      slide(t, params) {
        const p = t.processParams(params, { duration: 400, easing: 'easeInOut' });
        const parent = t.node.parentNode;
        const overflow = parent.style ? parent.style.overflow : '';
        const done = () => {
          t.complete();
          if (parent.style) setTimeout(() => parent.style.overflow = overflow);
        }
        if (parent.style) parent.style.overflow = 'hidden';
        if (t.isIntro || p.intro) {
          if (p.from === 'top') {
            t.setStyle({ transform: 'translateY(-100%)' });
            t.animateStyle({ transform: 'translateY(0)' }, p).then(done);
          } else if (p.from === 'bottom') {
            t.setStyle({ transform: 'translateY(100%)' });
            t.animateStyle({ transform: 'translateY(0)' }, p).then(done);
          } else if (p.from === 'left') {
            t.setStyle({ transform: 'translateX(-100%)' });
            t.animateStyle({ transform: 'translateX(0)' }, p).then(done);
          } else if (p.from === 'right') {
            t.setStyle({ transform: 'translateX(100%)' });
            t.animateStyle({ transform: 'translateX(0)' }, p).then(done);
          }
        } else {
          if (p.from === 'top') {
            t.setStyle({ transform: 'translateY(0)' });
            t.animateStyle({ transform: 'translateY(-100%)' }, p).then(done);
          } else if (p.from === 'bottom') {
            t.setStyle({ transform: 'translateY(0)' });
            t.animateStyle({ transform: 'translateY(100%)' }, p).then(done);
          } else if (p.from === 'left') {
            t.setStyle({ transform: 'translateX(0)' });
            t.animateStyle({ transform: 'translateX(-100%)' }, p).then(done);
          } else if (p.from === 'right') {
            t.setStyle({ transform: 'translateX(0)' });
            t.animateStyle({ transform: 'translateX(100%)' }, p).then(done);
          }
        }
      }
    }
  });

  let id = 0;
  export class Host extends Base {
    constructor(opts) { super(opts); this.defaults = {}; }

    get current() {
      const top = this.get('topLevel');
      return this.getWindow(this.get(`windows.${escape(top)}.id`));
    }

    get currentId() {
      const top = this.get('topLevel');
      return this.get(`windows.${escape(top)}.id`);
    }

    get placement () { return this.get('placement'); }
    set placement (v) { return this.set('placement', v); }

    get topmost () {
      const windows = this.get('windows');
      for (const k in windows) {
        if (windows[k].topmost) return this.getWindow(windows[k].id);
      }
    }

    get windows () { return Object.keys(this.get('windows')); }

    addWindow(window, opts) {
      const options = Object.assign({}, this.defaults, window.constructor.prototype.options, window.options, window.get('options'), opts);

      if (!(window instanceof Window)) {
        throw new Error('Windows must be instances of Window');
      }

      if (!window.id) window.set('@.id', options.id || `window${id++}`);
      if (!this.get(`windows.${escape(window.id)}`)) {
        this.set(`windows.${escape(window.id)}`, Object.assign({ show: options.show !== false, autosize: true, id: window.id, blockers: [], close: true, minimize: true, maximize: true, minWidth: '5em', minHeight: '5em' }, options, { id: window.id }));
      }

      window.host = this;
      const promise = this.attachChild(window, { target: 'window' });

      let parent;
      if (options.block) {
        parent = options.block.id || options.block;
        if (typeof parent === 'string' && parent in this.get('windows')) {
          this.push(`windows.${escape(parent)}.blockers`, window.id);
          window.set('control.blocking', parent);
        } else parent = false;
      }

      window.minSize(options.minWidth || '5em', options.minHeight || '5em');

      if (options.slide) {
      } else if (options.size === 'fill' && (parent || options.block)) {
        let wnd;

        if (options.block === true) wnd = this.find('.rwhost-pane');
        else if (wnd = this.getWindow(parent)) wnd = wnd.find('.rwindow');

        if (wnd) {
          window.size(wnd.clientWidth - (options.fillPad || 20), wnd.clientHeight - (options.fillPad || 20));
          if (options.block && !(options.top || options.left)) {
            options.top = options.left = Math.floor((options.fillPad || 20) / 2);
          }
        }
      } else if (options.width && options.height) {
        window.size(options.width, options.height);
      } else {
        window.size('auto');
      }

      if (options.slide) {
      } else if (options.top && options.left) {
        window.move(options.top, options.left);
      } else {
        this.place(window);
      }

      this.raise(window, { show: options.show !== false, parent: options.stickToParent });

      window.on('close', () => {
        const blocking = window.get('control.blocking');
        if (blocking) {
          const blockers = this.windowGet(blocking, 'blockers') || [];
          this.splice(`windows.${escape(blocking)}.blockers`, blockers.indexOf(window.id), 1);
        }
        this.detachChild(window).then(() => window.teardown());
        this.set(`windows.${escape(window.id)}.block`, false);
        this.set(`windows.${escape(window.id)}.index`, -1);
        this.raise();
        this.set(`windows.${escape(window.id)}`, undefined);
        delete this.get('windows')[window.id];
      });

      this.update(`windows.${escape(window.id)}.id`, { force: true });

      this.fire('add', {}, { window, options });

      return promise.then(() => window);
    }

    getWindow(id) {
      return this.children.byName.window && this.children.byName.window.filter(w => w.instance.id === id).map(w => w.instance)[0];
    }

    windowGet(id, path) {
      return this.get(`windows.${escape(id)}.${path}`);
    }
    windowSet(id, path, val) {
      return this.set(`windows.${escape(id)}.${path}`, val);
    }

    raise(window, opts = {}) {
      let wnd = window instanceof Window ? window : this.children.byName.window.filter(a => a.instance.id === window).map(a => a.instance)[0];
      const object = this.get('windows', { virtual: false });
      const host = this;
      const wnds = Object.keys(object).map(k => object[k]);
      let top = (wnds.length + 1) * 2;
      const last = this.get('topLevel');
      const wasBlocked = this.get('blocked');
      const id = wnd ? wnd.get('control.id') : wnds.reduce((a, c) => !a ? c : c.index > a.index ? c : a, null);

      if (!wnd && id) wnd = this.children.byName.window.find(a => a.instance.id === id);

      function blocks(ctrl) {
        if (ctrl.blockers) {
          ctrl.blockers.forEach((b, i) => {
            const w = wnds.find(w => w.id === b);
            if (!w) return;
            w.index = ctrl.index + i + 1;
            blocks(w);
          });
        }
      }

      function liftBlocked(control, pos) {
        if (!control) return;
        control.index = pos--;
        if (control.blocking) liftBlocked(wnds.find(w => w.id === control.blocking), pos);
        blocks(control);
      }

      if (wnd) {
        const ctrl = wnd.get('control');
        ctrl.index = opts.show === false ? -1 : top;
        blocks(ctrl);
        if (ctrl.blocking) liftBlocked(wnds.find(w => w.id === ctrl.blocking), top - 1);
        if (opts.show !== false && !ctrl.show) wnd.show();
      }

      wnds.filter(w => w.show !== false && w.block === true).forEach(w => {
        this.set(`windows.${escape(w.id)}.index`, (w.index || 0) + top);
        blocks(w);
      });

      const ordered = wnds.sort((l, r) => !l.show ? -1 : !r.show ? 1 : l.index < r.index ? -1 : 1);
      const visible = ordered.filter(w => w.show);
      top = ordered.indexOf(visible[visible.length - 1]);
      const sets = {};

      let modalIdx = null;
      ordered.forEach((w, i) => {
        const key = escape(w.id);
        if (w.block === true && modalIdx === null) modalIdx = i;
        sets[`windows.${key}.index`] = w.index = modalIdx !== null ? i + 2 : i;
        sets[`windows.${key}.topmost`] = i === top;
        sets[`windows.${key}.stack`] = ordered.length - i;
      });

      if (modalIdx !== null) {
        sets.blocked = modalIdx + 1;
      } else {
        sets.blocked = 0;
      }

      if (~top && ordered.length) sets.topLevel = ordered[top].id;
      else sets.topLevel = null;

      this.set(sets);

      top = sets.topLevel;
      if (top && top !== last && this.get('currentMax') && this.rendered) {
        const leaving = this.get(`windows.${escape(last)}`);
        wnd = this.getWindow(top);
        const transition = this.get('transition');
        if (transition !== false && !wnd.get('control.slide') && (!leaving || (!leaving.dialog && !leaving.slide) && (!leaving.blocking || (leaving.blocking && leaving.blocking !== top)))) wnd.transition(transition || 'window', wnd.find('div'), { intro: true });
      }

      this.fire('raise', {}, { top: this.topmost });
      if (last !== this.get('topLevel')) {
        const wnd = this.current;
        wnd && wnd.fire('raise', {}, { last: this.getWindow(last) });
      }
    }

    place(wnd) {
      if (!wnd.get('control.show')) return Promise.resolve();
      return new Promise(ok => {
        requestAnimationFrame(() => {
          const local = wnd.get('control');
          if (local.width === undefined && !local.dialog) wnd.size('auto');
          let left = 0;
          let top = 0;

          if (!(this.fragment && this.fragment.rendered)) return;

          const host = this.find('.rwhost');
          const maxw = host.clientWidth;
          const maxh = host.clientHeight;

          let lw = local.width;
          let lh = local.height;

          if (local.dialog && (!local.size || local.size === 'auto' || !local.width || !local.height)) {
            lw = sizeInEm(wnd.pane.clientWidth);
            lh = sizeInEm(wnd.pane.clientHeight);
          }

          // if it's blocking, center on blocked
          const blocking = local.blocking;
          if (blocking) {
            const key = `windows.${escape(blocking)}`;
            const blocked = this.get(key);
            const max = local.max || (!local.dialog && (this.get('max') || this.get('userMax')));
            const bmax = blocked.max || this.get('userMax') || this.get('max');
            const bw = bmax ? this.host.clientWidth : sizeInPx(`${blocked.width}em`);
            const bh = bmax ? this.host.clientHeight : sizeInPx(`${blocked.height}em`);
            const bl = bmax ? 0 : blocked.left;
            const bt = bmax ? 0 : blocked.top;

            left = (max ? maxw : bw / 2) + (max ? 0 : bl) - (sizeInPx(lw) / 2);
            top = (max ? maxh : bh / 2) + (max ? 0 : bt) - (sizeInPx(lh) / 2);
          }

          // place in 3x3 grid
          else {
            const place = this.get('placement');
            let pos;
            if (typeof place === 'function') {
              try {
                pos = place(this, host, local);
              } catch (e) {
                pos = placeGrid(this, host, local);
              }
            } else if (typeof place === 'string') {
              switch (place) {
                case 'smart':
                  pos = placeSmart(this, host, local);
                  break;
                default:
                  pos = placeGrid(this, host, local);
                  break;
              }
            } else {
              pos = placeGrid(this, host, local);
            }
            top = pos.top;
            left = pos.left;
          }

          if (isNaN(left) || left < 0) left = 10;
          if (isNaN(top) || top < 0) top = 10;

          wnd.set({
            'control.top': top,
            'control.left': left
          });

          ok();
        });
      });
    }
  }

  function placeGrid(host, target, node) {
    const maxw = target.clientWidth;
    const maxh = target.clientHeight;
    let top = 0, left = 0;
    //if (host._grid1 > 8) host._grid2 > 8 ? host._grid2 = 0 : ++host._grid2;
    const grid1 = host._grid1 === undefined ? (host._grid1 = 0) : host._grid1 > 7 ? (host._grid1 = 0) : ++host._grid1;
    // ignoring, for now
    //const grid2 = host._grid2 || (host._grid2 = 0);

    const width = Math.floor(maxw / 3);
    const height = Math.floor(maxh / 3);
    const localWidth = sizeInPx(node.width);
    const localHeight = sizeInPx(node.height + 'em');

    switch (grid1) {
      case 5: case 7: case 8:
        top = maxh - localHeight - 10;
        break;
      case 2: case 4: case 6:
        top = height + Math.floor((height - localHeight) / 2);
        break;
      case 0: case 1: case 3:
        top = 10;
        break;
    }

    switch (grid1) {
      case 3: case 6: case 8:
        left = maxw - localWidth - 10;
        break;
      case 1: case 4: case 7:
        left = width + Math.floor((width - localWidth) / 2);
        break;
      case 0: case 2: case 5:
        left = 10;
        break;
    }

    if (left + localWidth > maxw) left = maxw - localWidth - 10;
    if (top + localHeight > maxh) top = maxh - localHeight - 10;

    return { top, left };
  }

  function placeSmart(host, target, node) {
    const maxw = target.clientWidth - 10;
    const maxh = target.clientHeight - 10;
    let i, j;
    const cell = 16;
    const mh = Math.floor(maxh / cell), mw = Math.floor(maxw / cell);
    const grid = new Array(mh * mw);
    const dest = new Array(mh * mw);

    // init grid
    for (i = 0; i < grid.length; i++) {
      grid[i] = 0;
    }

    // fill in grid with window coords
    let win, t, l, w, h, wins = 0;
    const windows = host.get('windows');
    for (const k in windows) {
      wins++;
      win = windows[k];
      t = Math.floor(win.top / cell); l = Math.floor(win.left / cell); h = Math.ceil(sizeInPx(win.height) / cell); w = Math.ceil(sizeInPx(win.width) / cell);
      for (i = t; i < t + h && i < mh; i++) {
        for (j = l; j < l + w && j < mw; j++) {
          grid[i * mw + j]++;
        }
      }
    }

    // compute each cell
    let c, ii, jj;
    w = Math.ceil(sizeInPx(node.width) / cell);
    h = Math.ceil(sizeInPx(node.height) / cell);
    for (i = 0; i < mh; i++) {
      for (j = 0; j < mw; j++) {
        if (i + h > mh || j + w > mw) c = wins * w * h;
        else {
          c = 0;
          for (ii = 0; ii < h; ii++) {
            for (jj = 0; jj < w; jj++) {
              c += grid[(i + ii) * mw + j + jj];
            }
          }
        }
        if (c === 0) return { top: i * cell + 5, left: j * cell + 5 };
        dest[i * mw + j] = c;
      }
    }

    // if there were no blanks, find the smallest overlap
    c = wins * w * h;
    ii = 0;
    for (i = 0; i < dest.length; i++) {
      if (dest[i] < c) {
        c = dest[i];
        ii = i;
      }
    }

    return { top: Math.floor(ii / mw) * cell + 5, left: (ii % mw) * cell + 5 };
  }

  Base.extendWith(Host, {
    template: $TEMPLATE,
    use: [toast(), expand()],
    cssId: 'window-host',
    noIntro: true,
    attributes: ['placement', 'windows', 'transition'],
    observe: {
      '@style.raui.window.maxFrom'() {
        initMediaListener(this);
      },
      topLevel(v) {
        if (v) {
          this.link(`windows.${escape(v)}`, 'current');
        } else {
          this.unlink('current');
        }
      },
      currentMax: {
        handler(v) {
          (this.children.byName.window || []).forEach(w => w.instance.fire('resize'));
        },
        defer: true
      }
    },
    computed: {
      currentMax() {
        const top = this.get('topLevel');
        const max = this.get(`windows.${escape(top)}.max`);
        const user = this.get('userMax');
        return user || this.get('max') || max;
      }
    },
    on: {
      config() {
        let content = this.partials.content;
        if (content && Array.isArray(content)) {
          content = this.partials.content = content.slice();
          let i = content.length;
          while (i--) {
            const e = content[i];
            if (e.e === 'max-top') {
              content.splice(i, 1);
              this.set({
                _maxP: { t: e.f },
                hideTitleMax: true
              });
              if (e.m) {
                this.set({
                  _maxAttrsP: { t: e.m }
                });
              }
            }
          }
        }

        if (typeof window !== 'undefined') {
          let tm;
          this._resizeListener = () => {
            if (tm) return;
            tm = setTimeout(() => {
              tm = null;
              this.fire('resize');
            }, 300);
          }
          window.addEventListener('resize', this._resizeListener);
        }
      },
      teardown() {
        if (this._resizeListener) {
          window.removeEventListener('resize', this._resizeListener);
        }
      }
    }
  });

  function initMediaListener(r) {
    if (r._media) {
      r._media.fn();
    } else {
      r._media = {};
      r._media.fn = () => {
        if (!r.host) return;
        const max = sizeInPx(r.get('@style.raui.window.maxFrom'));
        const trans = r.transitionsEnabled;
        r.transitionsEnabled = false;
        r.set('max', r.host.clientWidth <= max);
        r.set('dimensions', { clientWidth: r.host.clientWidth, clientHeight: r.host.clientHeight });
        r.transitionsEnabled = trans;
      };
      r._media.handle = r.root.on('*.resize', r._media.fn);
      setTimeout(r._media.fn);
    }
  }

  function findEvent(instance) {
    let i = instance;
    while (i) {
      if (i.event && i.event) return i.event.event;
      i = i.parent;
    }
  }

  function getEventCoords(event) {
    const node = event.target;
    if (!node) return { x: 0, y: 0 };
    const rect = node.getBoundingClientRect();
    return { x: Math.round(rect.left + (rect.right - rect.left) / 2), y: Math.round(rect.top + (rect.bottom - rect.top) / 2) };
  }

  Ractive.transitions.modal = function(t, parms) {
    const params = t.processParams(parms, { duration: 400, easing: 'easeOut', x: 0, y: -50, event: true });
    const event = null;//params.event ? findEvent(this) : null;

    const current = { x: t.node.offsetLeft, y: t.node.offsetTop };

    let styles;
    const overflow = t.node.parentNode.style ? t.node.parentNode.style.overflow : 'hidden';

    if (!event && !t.node._modalSrc) {
      if (t.isIntro) {
        styles = { transform: 'translate(0, 0) scale(1, 1)', opacity: 1 };
        t.setStyle({ transform: `translate(${params.x}px, ${params.y}px) scale(0.5, 0.5)`, opacity: 0 });
      } else {
        styles = { transform: `translate(${params.x}px, ${params.y}px) scale(0.5, 0.5)`, opacity: 0 };
      }
    } else {
      const click = t.node._modalSrc || (event ? getEventCoords(event) : { x: current.x + params.x, y: current.y + params.y });

      const target = { x: click.x - Math.round(t.node.clientWidth / 2) - current.x, y: click.y - Math.round(t.node.clientHeight / 2) - current.y };

      if (t.node.parentNode.style) t.node.parentNode.style.overflow = 'hidden';

      if (t.isIntro) {
        t.node._modalSrc = click;
        styles = { transform: 'translate(0, 0) scale(1, 1)', opacity: 1 };
        t.setStyle({ transform: `translate(${target.x}px, ${target.y}px) scale(0.5, 0.5)`, opacity: 0 });
      } else {
        styles = { transform: `translate(${target.x}px, ${target.y}px) scale(0.5, 0.5)`, opacity: 0 };
      }
    }

    t.animateStyle(styles, params).then(() => {
      if (t.node.parentNode.style) t.node.parentNode.style.overflow = overflow;
      t.complete()
    });
  };

  const moveEvents = ['mousemove', 'mouseup', 'touchmove', 'touchend'];
  const handleSize = 7;

  export class Window extends Base {
    constructor(opts) { super(opts); }

    get resizable () { return this.get('control.resizable'); }
    set resizable (v) { return this.set('control.resizable', v); }
    get title () { return this.get('control.title'); }
    set title (v) { return this.set('control.title', v); }
    get visible () { return this.get('control.show'); }
    set visible (v) {
      if (v) this.show();
      else {
        if (this.get('control.show')) try { this.fire('hide'); } catch (e) {}
        this.set('control.show', v, { keep: true });
      }
      this.host.raise(this, { show: v });
    }
    get pad () { return this.get('pad'); }
    set pad (v) { this.set('pad', v); }
    get buttons () { return this.get('buttons'); }
    set buttons (v) { return this.set('buttons', v); }
    get blocked () { return this.get('control.blocked'); }
    set blocked (v) { return this.set('control.blocked', v); }

    get result () {
      if (!this._result) {
        this._result = {};
        this._result.promise = new Promise((ok) => {
          this._result.ok = ok;
        });
      }
      return this._result.promise;
    }

    setResult(v) {
      this.result;
      this._result.value = v;
    }

    close(force, result) {
      if (force !== true) {
        if (!this.parent) return false;
        if (this.get('control.blockers.length')) return false;
        if (typeof this.beforeClose === 'function' && this.beforeClose() === false) return false;
        if (this.fire('beforeClose') === false) return false;
      }

      this.fire('close');
      if (this._result) this._result.ok(this._result.value || result);

      return true;
    }

    maximize() {
      this.toggle('root.userMax');
    }

    hide() { this.visible = false; }

    raise(show) {
      this.host.raise(this, { show });
    }

    show() {
      const shown = this.get('control.show');
      this.set('control.show', true);
      if (this.get('control.top') === undefined) {
        this.host.place(this);
      }
      if (!shown) try { this.fire('show'); } catch (e) {}
    }

    size(w, h) {
      return new Promise(ok => {
        requestAnimationFrame(() => {
          if (!this.visible) {
            if (typeof w === 'number' && typeof h === 'number') {
              this.set({
                'control.width': sizeInEm(w),
                'control.height': sizeInEm(h),
                'control.naturalWidth': sizeInEm(w),
                'control.naturalHeight': sizeInEm(h),
                'control.autosize': false
              });
            }
            return ok();
          }

          const el = this.wrapper;
          if (!el) return ok();

          if (w === 'auto') {
            this.set('control.autosize', true);
            const nw = Math.ceil(sizeInEm(el.clientWidth + 16));
            const nh = Math.ceil(sizeInEm(el.clientHeight + 8));
            this.set({
              'control.width': nw,
              'control.height': nh,
              'control.naturalWidth': nw,
              'control.naturalHeight': nh,
              'control.autosize': false
            });
          }

          else if (typeof w === 'number' && typeof h === 'number') {
            this.set({
              'control.width': sizeInEm(w),
              'control.height': sizeInEm(h),
              'control.naturalWidth': sizeInEm(w),
              'control.naturalHeight': sizeInEm(h),
              'control.autosize': false
            });
          }

          else if (typeof w === 'string' && typeof h === 'string') {
            const ow = el.style.width;
            const oh = el.style.height;
            el.style.width = w;
            el.style.height = h;
            const nw = el.clientWidth;
            const nh = el.clientHeight;
            el.style.width = ow;
            el.style.height = oh;

            this.set({
              'control.width': sizeInEm(nw),
              'control.height': sizeInEm(nh),
              'control.naturalWidth': sizeInEm(nw),
              'control.naturalHeight': sizeInEm(nh),
              'control.autosize': false
            });
          }

          const hel = this.host.host;
          if (hel) {
            const maxw = sizeInEm(hel.clientWidth - 16);
            const maxh = sizeInEm(hel.clientHeight - 16);
            if (this.get('control.width') > maxw) this.set('control.width', maxw);
            if (this.get('control.height') > maxh) this.set('control.height', maxh);
          }
          const minw = this.get('control.minWidth') || 5;
          const minh = this.get('control.minHeight') || 5;
          if (this.get('control.width') < minw) this.set('control.width', minw);
          if (this.get('control.height') < minh) this.set('control.height', minh);

          this.fire('resize');

          ok();
        });
      });
    }

    minSize(w, h) {
      return new Promise(ok => {
        requestAnimationFrame(() => {
          if (!this.visible) {
            if (typeof w === 'number' && typeof h === 'number') {
              this.set({
                'control.minWidth': sizeInEm(w),
                'control.minHeight': sizeInEm(h),
              });
            }
            return ok();
          }

          const el = this.wrapper;
          if (!el) return ok();

          if (w === 'auto') {
            const auto = this.get('control.autosize');
            this.set('control.autosize', true);
            const nw = sizeInEm(el.clientWidth + 16);
            const nh = sizeInEm(el.clientHeight);
            this.set({
              'control.minWidth': nw,
              'control.minHeight': nh,
              'control.autosize': auto
            });
          }

          else if (typeof w === 'number' && typeof h === 'number') {
            this.set({
              'control.minWidth': sizeInEm(w),
              'control.minHeight': sizeInEm(h),
            });
          }

          else if (typeof w === 'string' && typeof h === 'string') {
            const ow = el.style.width;
            const oh = el.style.height;
            el.style.width = w;
            el.style.height = h;
            const nw = el.clientWidth;
            const nh = el.clientHeight;
            el.style.width = ow;
            el.style.height = oh;

            this.set({
              'control.minWidth': sizeInEm(nw),
              'control.minHeight': sizeInEm(nh),
            });
          }

          ok();
        });
      });
    }

    move(top, left) {
      return new Promise(ok => {
        requestAnimationFrame(() => {
          if (top === 'center') top = (this.host.modalPane.clientHeight / 2) - (this.wrapper.clientHeight / 2)
          else if (typeof top === 'string') top = sizeInEm(top);

          if (left === 'center') left = (this.host.modalPane.clientWidth / 2) - (this.wrapper.clientWidth / 2)
          if (typeof left === 'string') left = sizeInEm(left);

          const set = {};

          if (typeof top === 'number') set['control.top'] = top;
          if (typeof left === 'number') set['control.left'] = left;

          this.set(set);

          ok();
        });
      });
    }

    _startMove(event) {
      if (event.type === 'mousedown' && event.button !== 0) return;
      if (!this.get('control.topmost')) this.raise();
      if (~event.type.indexOf('mouse')) {
        if (!this.top || (!event.ctrlKey && event.target !== this.content && event.target !== this.top && !this.top.contains(event.target))) return;
      } else {
        if (event.targetTouches && event.targetTouches.length === 1 && event.target !== this.content && event.target !== this.top && !this.top.contains(event.target)) return;
      }

      const wnd = this.pane;
      const cursor = wnd.style.cursor;
      wnd.style.cursor = 'move';
      wnd.style.userSelect = 'none';

      let sx = event.x || event.clientX || (event.targetTouches && event.targetTouches[0].clientX) || 0;
      let sy = event.y || event.clientY || (event.targetTouches && event.targetTouches[0].clientY) || 0;
      const ox = this.get('control.left') || 0;
      const oy = this.get('control.top') || 0;
      const ow = wnd.clientWidth;
      const oh = wnd.clientHeight;

      const _move = (ev) => {
        const x = ev.x || ev.clientX || (ev.targetTouches && ev.targetTouches[0] && ev.targetTouches[0].clientX) || (ev.changedTouches && ev.changedTouches[0].clientX) || 0;
        const y = ev.y || ev.clientY || (ev.targetTouches && ev.targetTouches[0] && ev.targetTouches[0].clientY) || (ev.changedTouches && ev.changedTouches[0].clientY) || 0;

        let nx = ox + (x - sx);
        let ny = oy + (y - sy);
        if (nx < (ow < 30 ? 0 : 30 - ow)) nx = ow < 30 ? 0 : 30 - ow;
        if (ny < (oh < 30 ? 0 : 30 - oh)) ny = oh < 30 ? 0 : 30 - oh;
        if (nx < 0) nx = 0;
        if (ny < 0) ny = 0;

        this.set({
          'control.top': ny,
          'control.left': nx
        });

        if (ev.type === 'touchend' || ev.type === 'mouseup') {
          moveEvents.forEach(e => document.removeEventListener(e, _move, { passive: false }));
          wnd.style.cursor = cursor;
          wnd.style.userSelect = '';
        } else {
          ev.preventDefault();
        }
      }

      moveEvents.forEach(e => document.addEventListener(e, _move, { passive: false }));

      if (event.type.indexOf('mouse') === 0) return false;
    }

    _startResize(event) {
      if (event.target !== this.wrapper) return;
      if (event.type === 'mousedown' && event.button !== 0) return;

      if (this.get('control.autosize')) {
        this.size('auto');
      }

      if (!this.get('control.topmost')) this.raise();

      this.set('control.resizing', true);

      const el = this.wrapper;
      const ix = event.offsetX || (event.targetTouches && (event.targetTouches[0].pageX - el.getBoundingClientRect().left));
      const iy = event.offsetY || (event.targetTouches && (event.targetTouches[0].pageY - el.getBoundingClientRect().top));
      const size = this.get('@style.window.handleSize') || handleSize;
      const right = el.clientWidth - size * 2, bottom = el.clientHeight - size * 2;
      const min = 2 * size;

      const l = ix <= min || ix >= right;
      const t = iy <= min || iy >= bottom;

      const sx = event.x || event.clientX || (event.targetTouches && event.targetTouches[0].clientX) || 0;
      const sy = event.y || event.clientY || (event.targetTouches && event.targetTouches[0].clientY) || 0;

      const ox = this.get('control.left') || 0;
      const oy = this.get('control.top') || 0;
      const ow = sizeInPx(this.get('control.width'));
      const oh = sizeInPx(this.get('control.height'));
      const nh = sizeInPx(this.get('control.minHeight'));
      const nw = sizeInPx(this.get('control.minWidth'));

      let tm;
      const _resize = (ev) => {
        ev.preventDefault();

        const x = ev.x || ev.clientX || (ev.targetTouches && ev.targetTouches[0] && ev.targetTouches[0].clientX) || (ev.changedTouches && ev.changedTouches[0].clientX) || 0;
        const y = ev.y || ev.clientY || (ev.targetTouches && ev.targetTouches[0] && ev.targetTouches[0].clientY) || (ev.changedTouches && ev.changedTouches[0].clientY) || 0;

        let dx = l ? x - sx : 0;
        let dy = t ? y - sy : 0;

        // resizing from top/left requires top/left/width/height adjustments
        const set = {};

        if (iy <= size) {
          set['control.top'] = oy + dy;
          set['control.height'] = oh - dy;
        } else {
          set['control.height'] = oh + dy;
        }

        if (ix <= size) {
          set['control.left'] = ox + dx;
          set['control.width'] = ow - dx;
        } else {
          set['control.width'] = ow + dx;
        }

        if (set['control.width'] < nw) {
          delete set['control.width'];
          delete set['control.left'];
        }

        if (set['control.height'] < nh) {
          delete set['control.height'];
          delete set['control.top'];
        }

        if (set['control.left'] < 0) set['control.left'] = 0;
        if (set['control.top'] < 0) set['control.top'] = 0;

        if (set['control.width']) set['control.width'] = sizeInEm(set['control.width']);
        if (set['control.height']) set['control.height'] = sizeInEm(set['control.height']);

        this.set(set);

        if (ev.type === 'touchend' || ev.type === 'mouseup') {
          moveEvents.forEach(e => document.removeEventListener(e, _resize, { passive: false }));
          this.set('control.resizing', false);
          if (ow !== this.get('control.width') || oh !== this.get('control.height')) {
            if (tm) clearTimeout(tm);
            tm = null;
            this.fire('resize');
          }
        } else {
          if (!tm) {
            tm = setTimeout(() => {
              this.fire('resize')
              tm = null;
            }, 200);
          }
        }
      };

      moveEvents.forEach(e => document.addEventListener(e, _resize, { passive: false }));

      return false;
    }

    _sizeHandle(event) {
      if (event.target !== this.wrapper) return;
      const el = this.wrapper;

      if (event.type === 'mouseout') return el.style.cursor = 'auto';

      const x = event.offsetX, y = event.offsetY;
      const size = this.get('@style.window.handleSize') || handleSize;
      const right = el.clientWidth - size, bottom = el.clientHeight - size;

      const style = el.style;
      if ((x <= size + size && y <= size + size) || (x >= right - size && y >= bottom - size)) {
        style.cursor = 'nwse-resize';
      } else if ((x >= right - size && y <= size + size) || (x <= size + size && y >= bottom - size)) {
        style.cursor = 'nesw-resize';
      } else if ((x <= size || x >= right) && (y < bottom || y > size)) {
        style.cursor = 'ew-resize';
      } else if ((y <= size || y >= bottom) && (x < right || x > size)) {
        style.cursor = 'ns-resize';
      } else {
        style.cursor = 'auto';
      }
    }
  }

  const buttonAttrs = [ 'left', 'right', 'center', 'condition' ];
  Base.extendWith(Window, {
    template: $PARTIALS['window'],
    cssId: 'window',
    partials: {
      pane: $PARTIALS['pane'].t,
      title: $PARTIALS['title'].t,
      contents: $PARTIALS['contents'].t,
      status: $PARTIALS['status'].t
    },
    data() {
      return {
        buttons: [],
        visibleButtons: 0
      }
    },
    computed: {
      leftButtons() {
        return (this.get('buttons') || []).filter(b => b.where === 'left');
      },
      centerButtons() {
        return (this.get('buttons') || []).filter(b => b.where === 'center');
      },
      rightButtons() {
        return (this.get('buttons') || []).filter(b => !b.where || b.where === 'right');
      }
    },
    decorators: {
      button(node) {
        const ctx = this.getContext(node);

        ctx.add('visibleButtons');

        return {
          update() {},
          teardown() { ctx.subtract('visibleButtons'); }
        };
      }
    },
    on: {
      config() {
        let parent = Window.prototype.template;
        let child = this.template;
        if (typeof parent !== 'string' && !Array.isArray(parent) && parent.t) parent = parent.t;
        if (typeof child !== 'string' && !Array.isArray(child) && child.t) child = child.t;

        if (parent !== child) {
          if (!this.partials.hasOwnProperty('contents')) this.partials.contents = child;
          this.template = parent;
        }
      },
      construct() {
        const wnd = this.constructor;
        if (!wnd._constructed) {
          wnd._constructed = 1;
          const tpl = wnd.prototype.template.t.slice();
          const btns = tpl.find(e => e.e === 'buttons');
          wnd.prototype.template.t = tpl.filter(e => e.e !== 'buttons');

          function mapButton(b) {
            const attrs = b.m || [];
            const res = {
              partial: { t: [{ t: b.t, e: b.e, f: b.f, m: attrs.filter(a => !~buttonAttrs.indexOf(a.n)) }] },
              where: attrs.find(a => a.n === 'left') ? 'left' : attrs.find(a => a.n === 'center') ? 'center' : 'right'
            }
            res.partial.t[0].m.push({ t: 71, n: 'button' });
            return res;
          }

          if (btns) {
            wnd._btns = btns.f.filter(e => e.e === 'button' || e.e === 'not-button' || (e.t === 4 && (e.n === 50 || e.n === 51) && e.f.find(e => e.e === 'button' || e.e === 'not-button'))).map(n => {
              if (n.t === 4) {
                return n.f.filter(e => e.e === 'button' || e.e === 'not-button').map(bb => {
                  const attrs = bb.m || [];
                  const b = bb.e === 'button' ? mapButton(bb) : { partial: { t: bb.f || [] }, where: attrs.find(a => a.n === 'left') ? 'left' : attrs.find(a => a.n === 'center') ? 'center' : 'right' };
                  const f = { t: n.t, n: n.n, f: [b.partial.t[0]] };
                  if (n.r) f.r = n.r;
                  if (n.rx) f.rx = n.rx;
                  if (n.x) f.x = n.x;
                  b.partial = { t: [f] };
                  return b;
                });
              } else if (n.e === 'not-button') {
                const attrs = n.m || [];
                return [{ partial: { t: n.f || [] }, where: attrs.find(a => a.n === 'left') ? 'left' : attrs.find(a => a.n === 'center') ? 'center' : 'right' }];
              } else {
                const b = mapButton(n);
                return [b];
              }
            }).reduce((a, c) => a.concat(c), []);
          }
        }
      },
      init() {
        const wnd = this.constructor;
        if (wnd._btns && !this.get('buttons.length')) this.set('buttons', wnd._btns);
      }
    },
    observe: {
      'control.max root.max root.userMax control.width control.height root.dimensions.clientHeight root.dimensions.clientWidth': {
        handler(v, o, k) {
          if (!this.get('control.id')) return;
          const max = this.get('control.max') || this.get('root.userMax') || this.get('root.max');
          const actual = this.get('control.actual') || {};

          if (max) {
            if (!actual.max) {
              const root = this.wrapper;
              if (this.wrapper) {
                this.set(
                  'control.actual',
                  { width: sizeInEm(this.wrapper.clientWidth), height: sizeInEm(this.wrapper.clientHeight), max }
                );
              }
            } else if (~k.indexOf('client') && typeof v === 'number') {
              if (~k.indexOf('Width')) this.set('control.actual.width', sizeInEm(v));
              else if (~k.indexOf('Height')) this.set('control.actual.height', sizeInEm(v));
            }
          } else {
            if (typeof v === 'number') {
              if (~k.indexOf('width')) this.set('control.actual.width', v);
              else if (~k.indexOf('height')) this.set('control.actual.height', v);
            }

            if (actual.max) {
              this.set(
                'control.actual',
                { width: this.get('control.width'), height: this.get('control.width'), max }
              );
            }
            this.set('control.actual.max', false);
          }
        },
        init: false, defer: true
      }
    }
  });

  export function plugin(opts = {}) {
    return function({ instance }) {
      instance.components[opts.name || 'host'] = Host;
    }
  }

  globalRegister('RMWindowHost', 'components', Host);
  globalRegister('RMWindow', 'components', Window);

  Host.prototype.Window = Window;

  export default plugin;
</script>

<script rel="css">
  const primary = Object.assign({}, data('raui.primary'), data('raui.window.primary'));
  primary.action = Object.assign({}, data('raui.window.action'), data('raui.window.primary.action'));
  primary.host = Object.assign({}, data('raui.window.host'), data('raui.window.primary.host'));
  primary.title = Object.assign({ inactive: {} }, data('raui.window.title'), data('raui.window.primary.title'));
  return `
  .rwhost {
    position: relative;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: ${primary.host.bg || primary.bg || '#fff'};
  }

  .rwhost-pane {
    display: flex;
    position: relative;
    width: 100%;
    box-sizing: border-box;
    flex-grow: 2;
    overflow: auto;
    z-index: 1;
  }
  .rwhost-pane.blocked {
    overflow: hidden;
  }

  .rwhost-pane-content {
    flex-grow: 1;
  }

  .rwhost-modal {
    position: absolute;
    position: --webkit-sticky;
    position: sticky;
    top: 0;
    left: 0;
    z-index: -1;
    opacity: 0;
    transition: opacity 0.2s ease-in-out, z-index 0s linear 0.2s;
    background-color: #000;
    width: 100%;
    height: 100%;
  }
  .rwhost-modal-active {
    opacity: 0.5;
    z-index: 1;
    transition: opacity 0.2s ease-in-out, z-index 0s linear;
  }

  .rwindow-wrapper {
    display: inline-block;
    box-sizing: border-box;
    position: absolute;
  }
  .rwindow-wrapper.rwindow-resizing {
    transition: none;
  }

  .rwindow-wrapper.rwindow-resizable {
    padding: ${primary.handleSize || 7}px;
  }

  .rwindow-slide-left {
    height: 100%;
    left: 0;
  }
  .rwindow-slide-right {
    height: 100%;
    right: 0;
  }
  .rwindow-slide-top {
    width: 100%;
    top: 0;
  }
  .rwindow-slide-bottom {
    width: 100%;
    bottom: 0;
  }

  .rwindow-topmost > .rwindow {
    box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.3);
    opacity: 1;
  }

  .rwindow-modal {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.5);
    opacity: 0;
    z-index: -1;
    transition: opacity 0.4s ease-in-out, z-index 0s linear 0.4s;
  }
  .rwindow-modal.rwindow-blocked {
    opacity: 1;
    z-index: 50;
    transition: opacity 0.4s ease-in-out, z-index 0s linear;
  }

  .rwindow {
    position: relative;
    box-sizing: border-box;
    background-color: ${primary.bg || '#fff'};
    color: ${primary.fg || '#222'};
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    border-radius: 2px;
    overflow: hidden;
    width: 100%;
    height: 100%;
    min-width: ${primary.minWidth || '6em'};
    min-height: ${primary.minHeight || '6em'};
    transition: box-shadow 0.4s ease-in-out, opacity 0.4s ease-in-out;
  }
  .rwindow-max > .rwindow {
   border-radius: 0;
   box-shadow: none;
  }

  .rwindow-pane-top,
  .rwindow-max-top {
    background-color: ${primary.title.inactive.bg || primary.fg || '#222'};
    color: ${primary.title.inactive.fg || primary.bg || '#fff'};
    flex-shrink: 0;
  }

  .rwindow-max-top {
    flex-shrink: 2;
  }

  .rwindow-pane-top {
    display: flex;
    align-items: center;
  }

  .rwindow-topmost .rwindow-pane-top {
    background-color: ${primary.title.bg || primary.fga || '#07e'};
    color: ${primary.title.fg || primary.bg || '#fff'};
  }

  .rwindow-pane {
    display: flex;
    flex-direction: column;
    table-layout: fixed;
    width: 100%;
    height: 100%;
  }
  .rwindow-autosizing {
    display: block;
    box-sizing: border-box;
  }
  .rwindow-content {
    overflow: auto;
    flex-grow: 2;
    position: relative;
    box-sizing: border-box;
  }
  .rwindow-content.rwindow-pad {
    padding: 1em;
  }
  .rwindow-content.rwindow-flex {
    display: flex;
    flex-direction: column;
  }

  .rwindow-buttons {
    display: flex;
    flex-shrink: 0;
    padding: 0.5em;
    border-top: 1px solid ${primary.action.bc || primary.bc || '#ccc'};
    background-color: ${primary.action.bg || primary.bg || '#fff'};
    color: ${primary.action.fg || primary.fg || '#222'};
  }
  .rwindow-buttons.no-buttons {
    display: none;
  }
  .rwindow-left-buttons {
    text-align: left;
    flex-grow: 2;
  }
  .rwindow-left-buttons button {
    margin-right: 0.5em;
  }
  .rwindow-center-buttons {
    text-align: center;
    flex-shrink: 2;
  }
  .rwindow-center-buttons button {
    margin: 0 0.25em;
  }
  .rwindow-right-buttons {
    text-align: right;
    flex-grow: 2;
  }
  .rwindow-right-buttons button {
    margin-left: 0.5em;
  }

  .rwindow-title {
    overflow: hidden;
    text-overflow: ellipsis;
    padding: 0.5em;
    white-space: nowrap;
    box-sizing: border-box;
    flex-grow: 1;
  }

  .rwindow-controls {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    flex-grow: 1;
  }
  .rwindow-controls > div {
    margin: 0 1em 0 0;
    width: 0.7em;
    height: 0.7em;
    cursor: pointer;
  }
  .rwindow-minimize {
    border-bottom: 2px solid;
  }
  .rwindow-maximize {
    border: 2px solid;
  }
  .rwindow-controls > .rwindow-close {
    width: 0.5em;
    height: 1em;
    border-right: 2px solid;
    transform: rotate(45deg);
    transform-origin: center right;
    position: relative;
    margin-right: 1.5em;
  }
  .rwindow-close:before {
    cursor: pointer;
    height: 1.2em;
    width: 1.2em;
    top: 0.3em;
    left: 0.1em;
    content: ' ';
    transform: rotate(-45deg);
    transform-origin: center left;
    position: absolute;
  }
  .rwindow-close:after {
    cursor: pointer;
    height: 100%;
    width: 100%;
    top: 1px;
    left: calc(100% + 1px);
    content: ' ';
    border-left: 2px solid;
    transform: rotate(-90deg);
    transform-origin: center left;
    position: absolute;
  }
  .rwindow-max-top .rwindow-controls > .rwindow-close {
    margin-right: 0.5em;
  }
  ${typeof data('raui.window.extra') === 'function' ? data('raui.window.extra').call(this, data) : ''}
  `;
</script>
